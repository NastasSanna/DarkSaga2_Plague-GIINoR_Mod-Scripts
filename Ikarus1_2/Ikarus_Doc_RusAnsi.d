//######################################################
//
//  Документация к скрипт-пакету "Ikarus"
//      Автор   : Sektenspinner
//      Версия  : 1.1.4
//      Перевод : НастасьСанна /*NS*/
//
//######################################################

/*  
  СОДЕРЖАНИЕ  
      I.   ) Ограничения  
      II.  ) Требования / Установка  
              1. Ikarus под Gothic 2  
              2. Ikarus под Gothic 1  
              3. Установка  
      III. ) Основные понятия  
              1. Память, адресация и указатели  
              2. Классы  
              3. Неотображаемые простые типы данных  
      IV.  ) Классы  
      V.   ) Функции  
              1. Низкоуровневый доступ к памяти  
              2. Возможности парсера  
              3. Переходы  
              4. Строковые функции  
              5. Функции меню  
              6. Инициализация глобальных инстанций  
              7. Доступ к Ini  
                * 7.1. Настройки клавиш  
              8. Распознавание нажатий клавиш  
              9. Выполнение машинного кода  
             10. Вызов функций движка  
             11. Внешние библиотеки  
             12. Разное  
             13. "Скрытые" функции  
      VI.  ) Опасности  
      VII. ) Примеры
*/

//######################################
// I. ОГРАНИЧЕНИЯ
//######################################

"Ikarus" - это коллекция классов движка (или их отображений в памяти), а 
также некоторых возможностей для работы с этими классами. Икарус поможет  
преодолеть ограничения языка Daedalus, но в пределах возможностей движка 
ZenGin. Он позволяет использовать и изменять некоторые объекты и данные, 
которые недоступны иначе, включая кое-что интересное для моделлеров. Более 
того, функции движка могут быть вызваны из скриптов продвинутыми методами.
Икарус предоставляет лишь некоторые ограниченные возможности, позволяющие 
изменить поведение самого ZenGin.

//######################################
// II. ТРЕБОВАНИЯ / УСТАНОВКА
//######################################

Данный скрипт-пакет требует знания основ программирования, а также приличной 
доли настойчивости и исследовательского духа. Большая часть свойств классов 
не документирована, так что их применение чаще всего ведется методом проб и 
ошибок. Форум WoG - подходящее место для совместного изучения классов и их 
свойств, чтобы не приходилось каждый раз изобретать колесо.

//--------------------------------------
// 1.) Ikarus под Gothic 2
//--------------------------------------

Этот скрипт-пакет следует использовать только под лицензионной версией
Gothic 2. В других версиях скрипт-пакет может вызывать вылеты. Так что, если 
вы решить использовать его, убедитесь, что игроки мода также используют
лицензионную версию.
Версии новее 2.6.0.0 (по планам Nico) НЕ ДОЛЖНЫ вызывать проблем и будут 
полностью совместимы с данным пакетом.

//--------------------------------------
// 2.) Ikarus под Gothic 1
//--------------------------------------

Изначально Икарус разрабатывался только под Gothic II. Тем не менее, он 
достаточно хорошо сочетается с Gothic I версии 1.08k_mod (последняя версия 
playerkit). Все же, еще не все классы адаптированы под Gothic I. 
Непроверенные классы помечены в названии как ".unverified". На данный момент 
(сентябрь 2010) чаще всего вызывает вылеты zCMenuItem. oCAIHuman и zCCamera 
тоже не совсем доработаны.
Другие известные баги отсутствуют.

//--------------------------------------
// 3.) Установка
//--------------------------------------

Ikarus состоит из трех частей: константы, классы и ядро, и они должны 
компилироваться именно в этом порядке. Ядро Икаруса одинаково для
Готики 1 и 2 и включает общий файл Ikarus.d. Для констант и классов
присутствуют отдельные версии для Готики 1 и 2, компилировать следует
только нужную. 
Икарус использует класс C_NPC и потому должен компилироваться после него
(т.е. после файла classes.d). Других зависимостей нет.

В файле констант присутствуют пользовательские переменные, включая настройку 
вывода отладочной информации Икаруса. 

Например, можно разместить файлы Икаруса в папке скриптов Готики _intern и 
изменить Gothic.src следующим образом:

//******************

_INTERN\CONSTANTS.D
_INTERN\CLASSES.D

_INTERN\Ikarus_Const_G2.d
_INTERN\EngineClasses_G2\*.d
_INTERN\Ikarus.d

AI\AI_INTERN\AI_CONSTANTS.D
[...]

//******************

//######################################
// III. ОСНОВНЫЕ ПОНЯТИЯ
//######################################

Я пытался написать следующий текст так, чтобы даже "чайнику" была понятна 
идея. Это не означает, что прочитавший текст "чайник" сможет сразу эффективно 
его применять. Но я решил, что лучше написать слишком много, чем слишком 
мало.
Тот, кто хорошо знаком с программированием, может без проблем пропустить как 
минимум пункты 1 и 2.

//--------------------------------------
// 1.) Память, адресация и указатели

Память - это большая таблица с данными. Положение в таблице определяется 
адресом, положительным целым числом. Таким образом, определяется байт данных, 
доступный в ячейке памяти (байт состоит из 8 двоичных цифр (0 или 1), 
например 00101010). Часто адрес распространяется на данные (блок данных) в 
нескольких последовательных ячейках памяти, чаще всего четырех.

После запуска Готики, она размещается в памяти. "Готика" в обоих случаях - 
это и сама программа (машинный код), и данные, с которыми эта программа 
работает. Программа и данные размещаются в отдельных областях памяти
(сегментах), с различными правами доступа. В сегменте данных должен быть 
разрешен доступ к записи и чтению, и это именно тот сегмент, с которым 
работает скрипт-пакет. Когда Готика запущена, новые объекты постоянно 
создаются, а ненужные  удаляются, поэтому какой-нибудь нужный объект найти 
становится довольно сложно. К примеру, найти определенный сундук, потому что 
нельзя заранее сказать, где именно в памяти размещены данные об этом сундуке. 
Но некоторые объекты найти очень легко. Обычно имеются очень важные объекты, 
которые присутствуют только в одном экземпляре (и которые должно быть очень 
легко найти, иначе движок не сможет работать). Чаще всего, такие важные 
объекты всегда находятся в одном определенном месте (так что уже известно, 
где их искать, еще до запуска программы). В этом случае все, что нам нужно, 
чтобы найти нужную информацию - это доступ к месту ее хранения. Если же 
положение объекта в памяти неизвестно, иногда выделяется специальная область 
памяти, из которой можно узнать текущий адрес объекта. Так что мы можем найти 
нужный объект опосредованно, сначала просмотрев известную область, где 
записан его адрес, и использовать эту информацию для доступа к самому объекту.

Такую организацию можно сравнить с книгой. Представьте, что нам нужно найти 
главу 5. Если нам известно, что глава 5 начинается на 43 странице, мы можем 
открыть книгу на нужном месте. В общем случае, мы не знаем номер страницы
(потому что в разных книгах эта глава начинается на разных страницах). К 
счастью, у нас есть указатель - содержание, которое размещается в самом 
начале книги, т.е. мы можем использовать содержание и определить, где 
начинается глава 5. Зная это, найти главу 5 очень легко.

Поиск в памяти в целом очень похож на поиск в книге, благодаря тому, что 
известно, где находятся некоторые объекты. Они служат своего рода содержанием 
и включают ссылки на другие объекты. Такая ссылка называется указателем 
(pointer).

Пример:
В области памяти 0xAB0884 (16-ричное представление числа 11208836, также 
являющееся числом) всегда находится адрес текущей oGame (которая представляет 
собой множество данных с важной информацией о текущей игровой сессии). 
Перейдя по этой ссылке, получим объект типа oCGame. Этот объект содержит 
несколько свойств, включая свойство "world". Это тоже адрес, который 
указывает на объект типа oWorld. Он, в свою очередь, содержит ссылку на 
zCSkyController_Outdoor, который помимо всего прочего содержит текстуру, 
которая предоставляет нам данные... Так можно постепенно спуститься от общего 
целого до отдельного пикселя на небе.

//--------------------------------------
// 2.) Классы

Я уже упоминал об объектах, которые имеют свойства. Но дело обстоит так, что 
память компьютера сама по себе не имеет структуры, т.е. является 
"нетипизированной". Размещение данных не указывает на их содержание, 
например, являются ли они вещественным (дробным) числом, текстовой строкой 
или цветом. Т.е., даже если учитывать, что подразумевается под деревом, 
сундуком или NPC, необходимо точно определить, в каком порядке хранятся 
данные. Это называется размещением объекта в памяти (memory layout) и 
перечисляется в описании класса в Daedalus. Пример:

class cSandwich {		//бутерброд:
	var cToast upper;		//верхний тост  
	var cCheese cheese;		//сыр  
	var cToast lower;		//нижний тост
};

Это описание класса, который включает три подобъекта. В начале класса 
находится объект типа cToast (тост), затем следует объект класса cCheese (сыр) 
и в конце опять объект типа cToast. К сожалению, нельзя записать эту 
структуру в Daedalus прямо в таком виде, подобъекты необходимо разбить на 
простые типы. Если проследить, что собой представляют cToast и cCheese, можно 
описать отображение бутерброда в памяти как:

class cSandwich {  
	//var cToast upper;			//верхний тост  
      var int upper_browninggrade;	//степень прожарки  
      var int upper_butter;			//наличие масла  
	//var cCheese cheese;		//сыр  
      var string cheese_name;			//название  
      var int cheese_richness;		//жирность  
	//var cToast lower;			//нижний тост  
      var int lower_browninggrade;	//степень прожарки  
      var int lower_butter;			//наличие масла
};

Если у нас есть конкретный бутерброд sw, sw.cheese_name может быть, к 
примеру, "Эдам", и sw.lower_butter может быть равно 1, т.е. нижний тост будет 
намазан маслом.

Зная, что целое число (int) всегда занимает 4 байта, а строка (string) 20 
байт, мы получаем полную информацию и о классе. 

Предположим, что cSandwich расположен по адресу 123452 (адрес начала объекта)
, это значит, что по адресу 123452 находится значение "upper_browninggrade", 
по адресу 123456 (=123452 + 4) - значение "upper_butter", по адресу 123460 (=
123456 + 4) - значение строки "cheese_name", по адресу 123480 (=123460 + 20) 
 -  значение "cheese_richness" и т.д.

Хотя эти сведения и не являются необходимыми для использования данного 
пакета, я думаю, они будут полезны.

//--------------------------------------
// 3.) Неотображаемые простые типы данных

Не все простые типы данных (под "простым" подразумевается неделимый), 
известные в ZenGin, также доступны и в Daedalus. В Daedalus известны только 
целые числа (int) и строки (string) /*NS: а также числа с плавающей запятой 
(float), но они редко используются*/. Это не означает, что вы не сможете 
работать с другими типами данных, но нужно проявлять осторожность, чтобы 
обрабатывать их правильно.

Представьте, что у вас есть химическая лаборатория, где на всех бутылках 
написано "Дистиллированная вода", хотя на самом деле не все бутылки содержат 
воду. Химикаты, естественно, будут действовать так, как и должны, если вы 
знаете, что на самом деле скрывается под этикеткой. Но если вы воспользуетесь 
кислотой, как если бы это была вода, результат может быть непредсказуемым 
(вплоть до взрыва). 

"Дистиллированная вода" в нашем случае означает целое число, его размер равен 
32 битам. Все, что не является текстовой строкой, объявляется в классах 
данного пакета как целое число. Что на самом деле имеется в виду, становится 
ясно из комментариев.

Некоторые важные типы данных перечислены ниже.

//##### int ######

Если значение не только объявлено как int, но и в комментариях подписано как 
int, значит это int! Обычное 4-байтное знаковое целое.

//##### zREAL ####

zREAL - это 4-байтное вещественное число в формате IEEE, также известное как 
"single". Это число с плавающей запятой, которое обычно не используется в 
Daedalus. Но я написал функции для обработки таких чисел:
http://forum.worldofplayers.de/forum/showthread.php?t=500080
Например, в данном пакете присутствует функция roundf, которая преобразует  
zREAL к целому (округляет его).

//##### zBOOL ####

Также имеет размер 4 байта (избыточно). zBOOL - это тоже целое число, но с 
различением только вариантов "значение равно 0" и "значение не равно 0". 
Т.е., zBOOL означает истинность (правильность, выполнение) чего-либо. 0 
означает ложь/неверно/не выполняется (FALSE), 1 означает 
истина/верно/выполняется (TRUE).


//##### zDWORD ####

4-байтное беззнаковое целое. Это значит, что операторы сравнения <, <=, >, >= 
иногда дают неверный результат, поскольку большие значения zDWORD 
интерпретируются как отрицательные, хотя подразумевается положительное число. 
Но это имеет значение лишь в редких случаях, до тех пор, пока вы не 
пытаетесь записать отрицательное число, zDWORD можно использовать как целое 
int.

//#### zCOLOR ####

4-байтовое слово в памяти, каждый из которых представляет собой цветовой 
канал: синий, зеленый, красный (RGB) и альфа-канал (прозрачность). Каждый 
канал занимает 8 бит. Оранжевый цвет (orange) в 16-ричной форме записывается 
как:

0xFFFF7F00

синий канал:	00, данный цвет не содержит синего.
зеленый канал:	7F, цвет средней силы.
красный канал:	FF, самый яркий красный.
альфа-канал:	FF, отсутствие прозрачности.

Последовательность байт перевернута, поскольку используется порядок байт "от 
младшего к старшему" (little-endian), т.е. байт с меньшим порядком имеет 
меньший адрес. В памяти цвет будет представлен следующим образом:

Байт0: 00
Байт1: 7F
Байт2: FF
Байт3: FF

См. также примеры на "little-endian" в Википедии.

//##### zVEC3 #####

Этот тип данных не является простым, но часто используется: это тройка 
вещественных чисел zREAL, представляющая собой вектор в трехмерном 
пространстве. Объявляется как целочисленный массив длиной 3.

//## Указатели ###

Указатель - это 4-байтное слово в памяти, содержащее адрес другого объекта. 
Как правило, нам известен тип объекта, на который указывает указатель. Тип 
объекта, на который ссылается указатель, указывается со звездочкой *. 
Например, мы нашли запись:

var int ptr; //cSandwich*

ptr объявлен как целое int, но реальный тип данных указан в комментарии: это 
(не cSandwich, а) указатель на cSandwich (класс из предыдущего пункта). Если 
вы возьмете число из ptr и используете его как адрес, вы найдете cSandwich по 
этому адресу памяти. По следующим адресам вы найдете:

ptr + 0     : int upper_browninggrade
ptr + 4     : int upper_butter
ptr + 8     : string cheese_name
ptr + 28    : int cheese_richness
ptr + 32    : int lower_browninggrade
ptr + 36    : int lower_butter     

(заметьте, что int имеет длину 4 байта, а string - 20 байт).

Возможна ситуация, когда указатель не ссылается ни на какой объект. Тогда его 
значение равно 0 (null). Например, указатель на текущую игровую сессию может 
быть равен 0, если игрок еще находится в главном меню и сессия еще не 
существует.

Разумеется, существуют и указатели на указатели. Они обозначаются 
дополнительными звездочками **.

//######################################
// IV. КЛАССЫ
//######################################

Представленные здесь классы - это далеко не все, имеющиеся у движка. Здесь 
собраны те классы, которые мне показались наиболее интересными для 
модостроителей.

Я постарался для каждого класса под меткой "Полезно для" собрать примеры, для 
чего может пригодиться их знание и возможность доступа к ним. Возможно, 
некоторые из этих пунктов сложнее, чем мне кажется. Я не проверял большую их 
часть.

//########### oCGame #############

Содержит сведения о текущей игровой сессии и множество ссылок на глобальные 
объекты, например, мир (локация) или InfoManager. Некоторые настройки также 
представляют интерес.

Полезно для:
 - включения и отключения режима Marvin (game_testmode)
 - включения игровой паузы (singleStep)
 - переключения интерфейса, как для рабочего стола (game_drawall)
 - и др.

//##### oCInformationManager #####

Объект для отображения диалогов. Обеспечивает, например, вывод нужной 
информации в окне диалога.

Полезно для:
 - грязных трюков с isDone, напр., для отображения документов в диалоге
 - проверки, что сейчас происходит в диалоге, напр., когда игрок должен сделать 
выбор
 - ?

//######## oCInfoManager #########

Содержит список всех информационных сообщений (oCInfo).

Полезно для:
 - ?

//########## oCInfo ##############

В значительной степени раскрыт в Daedalus. Дополнительно, доступен список 
вариантов выбора (Choices) со свойством "told", которое в Daedalus можно 
получить функцией Npc_KnowsInfo.

Полезно для:
 - редактирования списка вариантов (Choices), можно реализовать функцию, 
которая выборочно удаляет пункты из списка
 - после выбора варианта узнать, какой именно вариант был выбран, даже если все 
варианты используют одну функцию
 - вре?менная разблокировка уже прозвучавшего диалога

//######## oCInfoChoice ##########

Содержит текст описания (description) и индекс вызываемой функции.

//#### oCMob и подклассы ####

В Спейсере известно множество MOB'ов. Особенно интересны запираемые (сундуки 
и двери).

Полезно для:
 - определения MOB'а в фокусе NPC (oCNpc.focus_vob) для редактирования, 
отпирания сундуков с помощью магии
 - запирания открытых NPC дверей

//######## zCVob и oCNpc #######

Полностью получены от Nico. Данный пакет позволяет получить полные сведения о 
oCNpc!

Полезно для:
 - чтения и редактирования положения в пространстве
 - анализа фокуса игрока
 - доступа к целой куче разных примочек

//############ oCItem ############

Скриптовые VOB'ы с известными свойствами. Дополнительно, свойства могут быть 
инстанциями, почти как скриптовые инстанции предметов (instance). Следует не 
забывать учитывать "amount" (количество, для выброшенных предметов) там, где 
это необходимо.

Полезно для:
 - сбора предметов под водой
 - Телекинеза?

//######### zCCamera #############

Просто камера. :-)
ОСТОРОЖНО: zCCamera - это НЕ zCVob. Но она содержит ссылку на связанный VOB 
(connectedVob).

Полезно для:
 - определения позиции камеры
 - гашения экрана (как в VFX, но проще).

//##### zCMenu / zCMenuItem ######

Главное меню - это zCMenu. Пункт "Новая игра" - это zCMenuItem. Есть и другие 
меню (напр., меню персонажа), которые тоже содержат свои zCMenuItem.

ВНИМАНИЕ: Некоторые из этих объектов создаются один раз и потом хранятся в 
памяти (даже при загрузке сохраненной игры!). Другие заново создаются в 
каждой игре.

Полезно для:
 - переработки меню персонажа (довольно халтурного)
 - отключения пункта "Сохранить" при определенных обстоятельствах (реализация 
точек или областей сохранения).

//########## zCOption ############

Содержит информацию из файлов настроек Готики Gothic.ini и мода [ModName]
.ini. В Икарусе доступны функции для чтения и записи данных.

Полезно для:
 - сохранения данных между игровыми сессиями (настройки сохранения/загрузки, 
сложность...)
 - чтения настроек персонажа (напр., видимость)

//########## zCParser ############

Парсер (синтаксический анализатор) - это не просто класс, который ругается на 
ваши скрипты, но и виртуальная машина, которая выполняет разобранный код. 
Парсер также содержит таблицу символов (хеш-таблицу).

Полезно для:
 - редактирования кода Daedalus'а во время выполнения (стек парсера).

//######## zCPar_Symbol ##########

Каждая логическая конструкция (переменная, инстанция, функция, класс) 
идентифицируется своим идентификатором (symbol). В основном, все эти объекты 
нумеруются по порядку. Этот номер можно узнать из таблицы символов парсера. У 
каждого из них есть имя и содержание, возможно, разных типов.

Полезно для:
 - "call by reference"
 - вызова функций по имени
 - редактирования смещения (offset) инстанций.

//#### zCSkyController_Outdoor ####

Включает все, что только можно сделать с небом. В частности, планеты (солнце 
и луну), таблицы цветов для освещения (разные для разного времени суток) (но 
не саму карту освещения, которая распространяется на полигоны) и текущие 
настройки дождя.

Полезно для:
 - включения дождя
 - перекрашивания солнечного света
 - изменения появления планет (солнце/луна)

//## zCTrigger и подклассы ###

zCTrigger, oCTriggerScript, oCTriggerChangeLevel и oCMover известны из 
Спейсера. Теперь вы можете получить доступ и к ним.

Полезно для:
 - изменения цели (target) oCTriggerScripts
 - построения триггер-цикла, который срабатывает в каждом кадре, путем вызова 
Wld_SendTrigger со свойством _zCVob_nextOnTimer, установленным в текущее 
время (см. zTimer).

//####### zCWaynet и Co #########

zCWaynet содержит список всех zCWaypoint'ов и всех oCWays (красные линии 
между WP). Сами zCWaypoint'ы не являются VOB'ами, но каждый zCWaypoint связан 
с определенным VOB'ом в мире (zCVobWaypoint), который является реальным VOB'
ом, и ничего более. Каждому oCWay известно, какие два zCWaypoints он 
соединяет, каждый zCWaypoints знает все oCWays, выходящих из него. 

Полезно для:
 - ?

//########### oWorld ##############

Остановимся на дереве VOB'ов (Vobtree), которое содержит все VOB'ы, а также 
такие штуки как SkyController и Waynet. Более того, помимо очень техничного 
Bsp-дерева имеется activeVobList, который содержит список всех активных VOB'
ов. Это NPC, триггеры и т.д. В каждом кадре activeVobList копируется в 
walkList, который последовательно просматривается.

Полезно для:
 - поиска объектов в мире, таких как NPC (voblist_npcs), предметы 
(voblist_items), все VOB'ы с AI, включая триггеры (activeVobList)
 - мне удалось взломать activeVobList и заморозить все, кроме ГГ, и вновь 
запустить позже

//######## zCZoneZFog #############

Fogzone - это зона тумана (возможно, окрашенного), ограничивающего видимость.

Полезно для:
 - возможных тайников с изменяющимися цветами
 - автоматической коррекции видимости на основе частоты кадров (framerate)

//####### РАЗНОЕ ###########

//zCTree
Узел дерева. Это может быть внутренний узел или лист. Содержит указатель на 
первый дочерний узел, на правого и левого соседа и на узел-предка. 
Разумеется, еще есть указатель на данные. Vobtree составлено из zCTree.

//zCArray
zCArray используется для управления массивами. zCArray содержит указатель на 
начало массива. Данные начинаются именно в этой ячейке памяти. zCArray также 
содержит число объектов в массиве (нельзя считывать данные после конца 
массива). При необходимости, выделяется дополнительный объем памяти, так что 
в zCArray кроме размера области данных, знает и объем зарезервированной 
памяти.

//zCArraySort
Почти как массив, за исключением того, что объекты в нем всегда отсортированы 
в определенном порядке (если только вы не нарушите этот порядок).

//zList
Самый общий вариант списка, использует свойство "next" общего типа. 
Практически не используется.

//zCList
Элемент списка. Содержит указатель на один объект (данные) и указатель на 
следующий элемент списка.

//zCListSort
Элемент списка, отсортированного в определенном порядке (если вы не нарушили 
это порядок).

//zCTimer
Позволяет узнать, сколько времени занимает кадр и настраивать минимальную и 
максимальную частоту кадров. Внимание! Может привести к "заморозке" игры!

//oCWorldTimer
Содержит игровое время (0 = 0:00, 6000000 = 24:00) и текущий день.

//oCSpawnManager
Содержит массив всех вставленных в игру NPC. Можно отключить спаун 
(spawningEnabled). Очень интересные величины: радиусы вставки и удаления 
являются статическими, но я привел их адреса в описании класса.

//oCPortalRoom и oCPortalRoomManager
Единственный oCPortalRoomManager знает все oCPortalRoom'ы. Также содержит 
сведения о том, в каком помещении находится игрок (curPlayerRoom) 
и где он был до этого (oldPlayerRoom). Каждый oCPortalRoom имеет своего 
владельца и гильдию.

//zCVobLight
Источник света. Предполагается, что Bsp-дереву должно быть известно, какие 
источники освещают текущий участок локации. Следовательно, неясно, в каких 
границах можно, например, перемещать источники света или увеличивать радиус 
освещения. А вот, например, цвет освещения можно легко изменить.

//oCMag_Book
Используется в цикле для выбора игроком заклинания. Дополнительно, класс 
содержит отображение: заклинание <-> предмет <-> кнопка.

//zString
Строка. Этот класс является примитивным типом Daedalus, поэтому в большинстве 
случаев доступ к отдельным свойствам не требуется. Тем не менее, я 
использовал эти свойства для реализации выделения памяти.

//######################################
// V. ФУНКЦИИ
//######################################

Функции Икаруса начинаются с префикса "MEM_". Это означает сокращение от 
"memory" и указывает, что кроме использования Икаруса, происходит 
взаимодействие с областью размещения Готики в памяти (что требует острожного 
обращения). Функции с префиксом "MEMINT_" являются внутренними ("private"), и 
относятся к функциям Икаруса, не имеющим значимых внешних приложений и, как 
минимум, недокументированным. Не гарантируется, что эти функции будут 
включены в более поздние версии Икаруса в той же форме. Исключением являются 
функции для работы со строками со своим собственным префиксом "STR_".

//######################################
// 1.) Низкоуровневый доступ к памяти

Чтение и запись строк и целых чисел осуществляются с помощью следующих 
функций:

func int    MEM_ReadInt     (var int address)
func void   MEM_WriteInt    (var int address, var int val)
func string MEM_ReadString  (var int address)
func void   MEM_WriteString (var int address, var string val)

Если адрес <= 0, выдается сообщение об ошибке. В противном случае, 
осуществляется попытка чтения или записи по указанному адресу. Если адрес 
является недопустимым в текущем диапазоне, например, участке кода, возникает 
Access Violation (Готика вылетит). Для операций со строками дополнительно 
необходимо, чтобы по указанному адресу находилась верная zString. Ели же там 
находится какая-нибудь ерунда, это может вызвать вылет Готики.

Примером использования MEM_WriteInt может служить следующая функция, которая 
включает или отключает отладочные сообщения:

//******************
func void MEM_SetShowDebug (var int on) {  
  MEM_WriteInt (showDebugAddress, on);
};
//******************

Дополнительно реализованы две связанные функции:

func int MEM_ReadIntArray  (var int arrayAddress, var int offset)
func int MEM_WriteIntArray (var int arrayAddress, var int offset, var 
int value)

Эти функции выполняют чтение/запись в массив по адресу (arrayAddress + 4 * 
offset). Например, можно считать i-тое вхождение в activeVoblist следующим 
образом:

//----------------------
func int GetActiveVob (var int i) {  
  MEM_InitGlobalInst(); //MEM_World должен быть инициализирован заранее  
    
  if (i >= MEM_World.activeVobList_numInArray)  
  || (i < 0) {  
      //выходит за границы массива  
      MEM_Error ("GetActiveVob: Попытка чтения за границами массива!");  
      return 0;  
  };  
    
  //получить i-тое вхождение в activeVobList:  
  return MEM_ReadIntArray (MEM_World.activeVobList_array, i);
};
//----------------------

Для доступа к отдельным байтам также реализованы:

func int  MEM_ReadByte  (var int adr)
func void MEM_WriteByte (var int adr, var int val)

В них обрабатывается только один байт по указанному адресу, а не всё 4-
байтное слово. Т.е. следующие 3 байта остаются нетронутыми. Если значение не 
входит в диапазон 0 <= val < 256 в MEM_WriteByte выводится предупреждение с 
указанием val. В частности, нельзя передавать отрицательные значения.

//######################################
// 2.) Возможности парсера

Использование одного только адреса объекта довольно неудобно для доступа к 
его свойствам. Гораздо проще, если объект является инстанцией (экземпляром) и 
доступ к любым его свойствам возможен в виде "инстанция.свойство". 
Существуют следующие функции:

func instance MEM_PtrToInst  (var int ptr)
func void     MEM_AssignInst (var int inst, var int ptr)

В принципе, они обе служат одной цели. 
MEM_PtrToInst получает указатель на объект ptr и возвращает инстанцию, 
которую можно использовать для присваивания.
MEM_AssignInst получает в качестве параметров инстанцию inst (фактически, ее 
индекс из таблицы символов) и указатель адреса ptr и связывает эту инстанцию 
с ptr.

ПРАВИЛО: Следующие формулировки эквивалентны:
1.) inst = MEM_PtrToInst (ptr);
2.) MEM_AssignInst (inst, ptr);

inst может быть объектом любого типа. ptr - это адрес (целое число). 

Пример использования:

//----------------------

func void somefunc() {  
  //Получаем инстанцию ГГ  
  var oCNpc her;  
  her = Hlp_GetNpc (PC_HERO);   
    
  //Есть ли у ГГ VOB в фокусе?  
  if (!her.focus_vob) { return; };  
    
  //Записываем her.focus_vob в myFocusVob  
  var zCVob myFocusVob;  
  myFocusVob = MEM_PtrToInst (her.focus_vob);  
    
  //Используем myFocusVob, напр. выводим его имя  
  Print (myFocusVob._zCObject_objectName);
};

//----------------------

Обратная функция к MEM_PtrToInst - это MEM_InstToPtr. Эта функция возвращает 
адрес объекта по полученной инстанции:

func int MEM_InstToPtr (var instance inst)

Например, MEM_InstToPtr (hero) вернет адрес памяти для ГГ.

Функция для получения инстанции из другой инстанции:

func instance MEM_CpyInst (var int inst)

Следующие фрагменты кода эквивалентны:
1.) selfCopy = MEM_CpyInst (self);
2.) selfCopy = MEM_PtrToInst (MEM_InstToPtr (self));

Примечание: Существует псевдоним MEM_InstToPtr под названием 
MEM_InstGetOffset.

Примечание: Инстанция определенного типа и переменная того же типа 
эквивалентны. В примере выше можно объявить "myFocusVob" вне функции как 
"instance myFocusVob (zCVob);".

Примечание: MEM_AssignInst и MEM_PtrToInst выдают предупреждение, 
если ptr == 0, потому что назначение нулевого (null) указателя чаще всего не 
является намеренным. Чтобы намеренно назначить 0 используйте 
MEM_AssignInstNull или MEM_NullToInst. Эти функции используются полностью 
аналогично, за исключением того, что параметр ptr опускается.

Примечание: MEM_AssignInst в отличие от MEM_PtrToInst, может применяться для 
изменения инстанции в других участках кода. Как правило, в этом не возникает 
необходимости.

//******************

Во время парсинга не всегда известно, когда нужно будет вызвать определенную 
функцию. Если, например, вы хотите вызвать функцию на проверку условия, 
привязанную к MOB'у в фокусе игрока (из ConditionFunс), это невозможно 
сделать до компиляции, поскольку невозможно угадать, какой именно MOB 
окажется в фокусе игрока. В Икарусе предусмотрена возможность вызова функции 
по имени или индексу символа. В примере с MOB'ом в фокусе, имя функции легко 
узнать из свойств MOB'а.

Эти функции легко объяснить и использовать:

func void MEM_CallByString (var string fnc)
func void MEM_CallByID (var int ID)

MEM_CallByString вызывает функцию с именем fnc, которое должно быть написано 
ЗАГЛАВНЫМИ БУКВАМИ. MEM_CallByID вызывает функцию по индексу ее символа ID. 
Индекс символа функции можно узнать с помощью MEM_FindParserSymbol или 
MEM_GetFuncID (см. ниже). 
MEM_CallByID работает быстрее, чем MEM_CallByString, и ее предпочтительно 
использовать, если функцию нужно вызвать много раз.

Если у вызываемой функции есть параметры, их необходимо сначала поместить в 
стек. Это можно сделать с помощью функций:

func void MEM_PushIntParam (var int param)
func void MEM_PushStringParam (var string strParam)
func void MEM_PushInstParam (var int instance)

Параметры необходимо проталкивать в стек в правильном порядке, слева направо. 
Если функция возвращает значение, его необходимо извлечь из стека после 
вызова, иначе можно вызвать переполнение стека (возможны и случаи, когда само 
возвращаемое значение содержит необходимую информацию). Это выполняется с 
помощью функций:

func int      MEM_PopIntResult()
func string   MEM_PopStringResult()
func instance MEM_PopInstResult()

См. пример 5.

Примечание: Эти функции работают без ограничений для внешних вызовов.

//******************

В дополнение к последнему разделу:

func int MEM_GetFuncID(var func function)

Возвращает индекс символа функции, который может быть использован, например, 
в MEM_CallByID. Функцию не обязательно объявлять (в порядке компиляции) до 
того, как она будет передана в MEM_GetFuncID.

func void MEM_Call(var func function)

Эквивалентно MEM_CallByID(MEM_GetFuncID(function)). Позволяет выполнять две 
интересных вещи: во-первых, возможно двум функциям вызывать друг друга (по-
другому это проблематично, потому что функция обязательно должна быть 
объявлена до своего вызова), и, во-вторых, такой вызов позволяет использовать 
функции в качестве параметров и таким образом конструировать модульные 
алгоритмы. Вот пример:

//----------------------

func void DoTwice(var func f) {  
  /* Можно использовать MEM_Call(f) напрямую.  
   * Для демонстрационных целей, однако,  
   * выполним присваивание функции: */  
  var func g; g = f; //(*)  
  MEM_Call(g);  
  MEM_Call(g);
};

func void bar() {  
  DoTwice(foo); //дважды выведет "Hello"
};

func void foo() {  
  Print("Hello");
};

//----------------------

Замечания:
 -  Переменные классов вызывают существенные проблемы. MEM_Call не позволяет, к 
примеру, вызвать функцию on_equip какого-нибудь предмета. Только обычные 
"var func" работают вне классов.
 -  Готика ведет себя очень глупо при передаче тэгов функций. В примере выше в 
строке, отмеченной (*) не происходит передачи f в g. Вместо того, чтобы 
поместить индекс символа f в g, g начинает ссылаться на f. Такое поведение 
приводит к тому, что MEM_Call выстраивает цепочку вызовов: MEM_Call.fnc -> 
DoTwice.g -> DoTwice.f -> foo, пока foo не будет наконец-то вызвана. Но если 
вместо (*) мы напишем "f = g;", эта цепочка будет разорвана, и f и g начнут 
циклически ссылаться друг на друга. MEM_Call приведет к бесконечному циклу. Я 
обсуждал это с примерами:

http://forum.worldofplayers.de/forum/threads/
969446-Skriptpaket-Ikarus-3/page11?p=17243175&viewfull=0#post17243175

//******************

func int MEM_FindParserSymbol (var string inst)

Возвращаемое значение: индекс символа с именем inst, если он существует. Если 
не существует, будет выдано предупреждение и функция вернет -1. Следующим 
шагом является функция:

func int MEM_GetParserSymbol (var string inst)

Она также находит символ с именем inst, но возвращает не индекс в таблице 
символов, а указатель на соответствующий zCPar_Symbol. Если таковой символ 
отсутствует, выдается предупреждение и функция возвращает 0.

Так что можно просматривать и редактировать переменные по имени. Пример:

//----------------------

func void SetVarTo (var string variableName, var int value) {  
  var int symPtr;  
  symPtr = MEM_GetParserSymbol (variableName);  
    
  if (symPtr) { //!= 0   
      var zCPar_Symbol sym;  
      sym = MEM_PtrToInst (symPtr);  
        
      if ((sym.bitfield & zCPar_Symbol_bitfield_type)  
                                    == zPAR_TYPE_INT) {  
          sym.content = value;  
      } else {  
          MEM_Error ("SetVarTo: Переменная не является целой!");  
      };  
  } else {  
      MEM_Error ("SetVarTo: Переменная не существует!");  
  };
};

func void foo() {  
  var int myVar;  
  SetVarTo ("FOO.MYVAR", 42); //эквивалентно myVar = 42;
};

//----------------------

//######################################
// 3.) Переходы
/*NS: Дословно - прыжки (jumps) */

Предоставляют весьма элегантные возможности. Используя две простые строки  
(это относится к низкоуровневому машинному коду, который генерируется при 
компиляции скриптов), можно запросить и установить текущую позицию стека 
парсера. При изменении позиции в стеке, выполнение будет продолжено с этой 
новой позиции.

Пример: Следующий код выведет числа от 0 до 42:

//----------------------

func void foo() {  
  /* Инициализация */  
  MEM_InitLabels();  
  var int count; count = 0;  
    
  /* Ставим метку label в текущей позиции. */  
  var int label;  
  label = MEM_StackPos.position;  
  /* <---- Метка теперь установлена здесь,  
   * в точке ПОСЛЕ присваивания метки. */  
    
  Print (ConcatStrings ("ЧИСЛО: ", IntToString (count)));  
  count += 1;  
    
  if (count <= 42) {  
      /* Подменяем текущую позицию,  
       * на позицию, отмеченную "<-----" */  
      MEM_StackPos.position = label;  
  };  
    
  /* При достижении 43, покидаем цикл. */
};

//----------------------

ВАЖНО: MEM_InitLabels() нужно запускать после загрузки сохраненной игры 
только один раз. Проще всего вызывать ее из INIT_GLOBAL. 
MEM_StackPos.position можно использовать только после вызова этой функции!

Примечание: MEM_InitLabels также вызывается из функции MEM_InitAll.

ВАЖНО: На практике, конечно: Метка должна быть инициализирована до того, как 
вы совершите переход к ней! Переходы вперед в общем случае довольно сложны, 
поскольку в этом случае происходит разрыв.

ВАЖНО: Метки нельзя сохранять и загружать. Т.е. метка должна использоваться 
немедленно. Тем более, я не вижу никакого повода, чтобы сохранять их надолго.

ВАЖНО: Кто скачет туда-сюда между разными функциями, и не знает, что делает, 
 - наступает на грабли. Кто ожидает с меткой в руках, и не знает, что делает, 
 - повторяет его ошибку. Мораль: Кто еще выполняет такого рода присваивания, 
на грабли может наткнуться.

//######################################
// 4.) Строковые функции

//******************

func int STR_GetCharAt (var string str, var int pos)

Возвращает символ с номером pos в строке str (имеется в виду числовое 
значение символа из таблицы ASCII). Отсчет начинается с 0. Например, 
TR_GetCharAt ("Hello", 1) == 101, т.к. в позиции 1 стоит символ 'e' и его код 
в таблице ASCII равен 101.

//******************

func int STR_Len (var string str)

Возвращает длину строки в символах.

//******************

const int STR_GREATER =  1;
const int STR_EQUAL   =  0;
const int STR_SMALLER = -1;

func int STR_Compare (var string str1, var string str2) {  
  
Возвращает STR_GREATER, если str1 лексикографически следует после str2 и, 
соответственно, STR_SMALLER или STR_EQUAL в других случаях. Примеры:

STR_Compare ("A", "B")      -> STR_SMALLER
STR_Compare ("ABC", "ABC")  -> STR_EQUAL
STR_Compare ("AA","A")      -> STR_GREATER
STR_Compare ("BA", "BB")    -> STR_SMALLER
STR_Compare ("B", "a")      -> STR_SMALLER
STR_Compare ("A", "")       -> STR_GREATER

(в предпоследнем примере следует отметить, что заглавные буквы по иронии 
судьбы "меньше", чем строчные буквы, так они представлены в такой 
последовательности в таблице ASCII).

//******************

func int STR_ToInt (var string str)

Преобразует строковое представление целого числа в это число. Например, 
строка "42" преобразуется в целое 42.

Примеры правильных строк:
1.) 42
2.) +42
3.) -42

Примеры неправильных строк:
1.) ++42
2.) 42+
3.) 4.2
4.) HelloWorld

В случае ошибки выдается предупреждение и возвращается 0.

//******************

func string STR_SubStr (var string str, var int start, var int count)

Возвращает подстроку str, начиная с индекса start длиной count.

Примеры:
STR_SubStr ("Hello World!", 0, 5): "Hello"
STR_SubStr ("Hello World!", 6, 5): "World"

Для частных случаев реализована следующая функция:

func string STR_Prefix (var string str, var int count)

STR_Prefix возвращает строку, состоящую из первых count символов строки str.
Идентично STR_SubStr с start == 0.

//******************

func string STR_Upper(var string str)

Возвращает копию строки str в верхнем регистре. На национальные символы 
(умляуты, кириллица) не действует, что соответствует поведению движка 
(zString::ToUpper). ASCII-символы обрабатываются корректно.

//*********************

func int    STR_SplitCount(var string str,  
                         var string Seperator)
func string STR_Split     (var string str,  
                         var string Separator, var int index)

STR_Split разбивает исходную строку str на части, используя разделитель 
Separator. Параметр index определяет номер извлекаемой строки.

Например, можно разбить предложение на отдельные слова, используя пробел в 
качестве разделителя:

//----------------------
func void foo() {  
  var string str;  str  = "Здесь написано какое-то предложение.";  
  var string tok1; tok1 = STR_Split(str, " ", 0);  
  var string tok2; tok2 = STR_Split(str, " ", 1);  
  var string tok3; tok3 = STR_Split(str, " ", 2);  
  var string tok4; tok4 = STR_Split(str, " ", 3);
};
//----------------------

В результате применения функции получаем tok1 == "Здесь", tok2 == "написано", 
tok3 == "какое-то" и tok4 == "предложение.".

Функция STR_SplitCount показывает, сколько частей содержит исходная строка. В 
контексте предыдущего примера STR_SplitCount(str, " ") == 4.

Примечание: Результатом разбиения могут быть и пустые строки. Например, 
разбиение строки "..abc" на 3 строки с разделителем "." приведет к результату 
"", "" и "abc". Аналогично, разбиение пустрой строки "" с любым разделителем 
вернет пустую строку.

//*********************

func int STR_IndexOf(var string str, var string tok)

STR_IndexOf ищет в строке str первое вхождение подстроки tok и возвращает 
индекс символа, с которого начинается вхождение. Если подстрока tok не 
найдена, функция возвращает -1.

Функция чувствительна к регистру символов.

Примеры:

//----------
STR_IndexOf("Hello World!", "Hell")  ==  0
STR_IndexOf("Hello World!", "World") ==  6
STR_IndexOf("Hello World!", "Cake")  == -1
STR_IndexOf("Hello World!", "")      ==  0
STR_IndexOf("Hello", "Hello World!") == -1
STR_IndexOf("hello Hell!", "Hell")   ==  6
STR_IndexOf("", "")                  ==  0
//----------



//######################################
// 5.) Функции меню

Эти функции включены в пакет для упрощения доступа к пунктам меню (например, 
меню персонажа). К сожалению, некоторые меню каждый раз генерируются заново 
(из скриптов), в то время как другие создаются один раз и сохраняются. 
Проблема: меню персонажа создается только после первого вывода на экран, и 
после этого сохраняется в памяти. И в зависимости от того, что именно вы 
хотите сделать, может быть удобно ввести изменения в скриптах меню или 
получить меню как объект и побезобразничать в готовом объекте. В последнем 
случае нам помогут:

func int MEM_GetMenuByString (var string menu)
func int MEM_GetMenuItemByString (var string menuItem)

Возвращает адрес меню menu или пункта меню menuItem, если они существуют, 
иначе 0.

//######################################
// 6.) Инициализация глобальных инстанций

Скрипт-пакет вводит следующие инстанции:

instance MEM_Game           (oCGame);
instance MEM_World          (oWorld);
instance MEM_Timer          (zCTimer);
instance MEM_WorldTimer     (oCWorldTimer);
instance MEM_Vobtree        (zCTree);
instance MEM_InfoMan        (oCInfoManager);
instance MEM_InformationMan (oCInformationManager);
instance MEM_Waynet         (zCWaynet);
instance MEM_Camera         (zCCamera);
instance MEM_SkyController  (zCSkyController_Outdoor);
instance MEM_SpawnManager   (oCSpawnManager);

У используемых здесь классов есть кое-что общее: одновременно может 
существовать лишь ограниченное число объектов каждого класса (так, не может 
существовать одновременно два мира или два неба).

Я сделал доступными функции, которые устанавливают смещение этих инстанций 
для связанного уникального объекта.

func void MEM_InitGlobalInst()

После вызова MEM_InitGlobalInst можно использовать все вышеперечисленные 
объекты. После загрузки игры необходимо снова вызывать MEM_InitGlobalInst()!

Примечание: MEM_InitGlobalInst также вызывается из функции MEM_InitAll.

//######################################
// 7.) Доступ к Ini

Ini-файлы имеют следующий формат:

//----------------------
[mySection1]
myOption1=myValue1
myOption2=myValue2
[mySection2]
myOption1=myValue1
myOption2=myValue2
//----------------------

Названия в квадратных скобках обозначают разделы (section). Внутри раздела 
каждый параметр (option) идентифицируется уникальным именем. Каждый параметр 
имеет значение (value), записанное после знака "=". Ini-файлы не являются 
бинарными, названия секций, имена параметров и их значения являются 
строковыми.

В данном скрипт-пакете присутствуют функции для записи и чтения в Gothic.ini, 
а также для доступа в ini-файл мода. Для чтения:

func string MEM_GetGothOpt (var string sectionname,  
                            var string optionname)
func string MEM_GetModOpt  (var string sectionname,  
                            var string optionname)

MEM_GetGothOpt просматривает Gothic.ini, MEM_GetModOpt - ini-файл 
мода для поиска параметра с именем optionname в разделе sectionname. Если 
такой раздел и такой параметр в ней существуют, возвращается значение 
параметра. В противном случае возвращается пустая строка. 

Я также написал функции, которые проверяют, существуют ли раздел и параметр. 
Думаю, вы с ними и сами разберетесь:

func int MEM_GothOptSectionExists (var string sectionname)
func int MEM_GothOptExists (var string sectionname,  
                            var string optionname)
func int MEM_ModOptSectionExists (var string sectionname)
func int MEM_ModOptExists (var string sectionname,  
                           var string optionname)

Для записи в Gothic.ini используется следующая функция:

func void MEM_SetGothOpt (var string section,  
                          var string option,  
                          var string value)

Параметру option в разделе section присваивается значение value. Если 
раздел/параметр не существует, они будут созданы.

Ini-файл мода, к сожалению, не может быть изменен, поскольку Готика никогда 
не выполняет его запись на диск.

//ЗАМЕЧАНИЯ:
 - Если вы вводите свои параметры, хороший тон диктует выделять для них новую 
секцию! Как правило, предполагается, что мод с названием "myMod" будет 
размещать параметры в секции "myMod" или "MOD_mymod" (а не в "GAME" или 
"PERFORMANCE").
 - Gothic.ini сохраняется, только когда вы нормально выходите из Готики. В 
случае падения игры изменения будут потеряны.
 - Некоторые изменения будут отображены только после перезапуска Готики или 
входа/выхода в главное меню.

//Применение параметров:
 - В ini-файле мода можно разместить дополнительные настройки, которые включают 
и отключают какие-то особенности вашего мода, которые могут понравиться не 
всем игрокам.
 - В Gothic.ini можно разместить настройки для каждого сохранения, так что не 
придется их переопределять при каждой загрузке мода, например, уровень 
сложности.
 - В Gothic.ini можно сохранить, был ли мод запущен хотя бы раз. Так что в 
следующий раз прохождение можно изменить.
 - В Gothic.ini можно сохранять лучшие результаты (вместе с именем компьютера 
idComputerName для возможности сравнения).
 - В Gothic.ini можно разместить статистическую информацию, такую как частоту 
загрузки игры (всего или за последнее время). Если игрок умирает слишком 
часто, возможно, уровень сложности слишком трудный.
 - и др.

//Примечание:
Пункты меню являются естественным способом внесения изменения в Gothic.ini. 
Так что предоставляется еще один вариант настройки Готики: считывать 
изменения непосредственно из Gothic.ini, а не из пункта меню.

//********************************
// 7.1.) Настройки клавиш

В Gothic.ini назначаются соответствия реальных кнопок на клавиатуре 
(например, "w") логическим клавишам (например, "keyUp" для бега вперед).

Представление внутреннего формата этих настроек немного запутано, поэтому 
вводятся следующие функции:

func int MEM_GetKey         (var string name)
func int MEM_GetSecondaryKey(var string name)

Обе ожидают получения имени логической клавиши, (например, "keyUp" 
или "keyInventory"). Они возвращают первичную или вторичную кнопку, связанную 
с этой логической клавишей. Если такого логического ключа нет, или для него 
не задана вторичная кнопка, возвращается 0, иначе возвращается код кнопки на 
клавиатуре, как он определен в Ikarus_Const.d. Этот код может быть 
использован, например, как параметр для MEM_KeyPressed или MEM_KeyState.

Пример: Чтобы узнать, что игрок нажал кнопку, открывающую инвентарь, 
необходимо очень часто (лучше всего в каждом кадре) проверять условие:  
   MEM_KeyPressed(MEM_GetKey         ("keyInventory"))  
|| MEM_KeyPressed(MEM_GetSecondaryKey("keyInventory"))

//######################################
// 8.) Распознавание нажатий клавиш

Простейшей является следующая функция:

func int MEM_KeyPressed(var int key)

Возвращает 1, если кнопка клавиатуры нажата, под key подразумевается ее 
виртуальный код. Коды содержатся в Ikarus_Const.d.

Используя MEM_KeyPressed(KEY_RETURN), например, можно проверить нажатие 
клавиши ENTER.

//######################

Зачастую ожидание нажатий клавиш осуществляется в триггер-цикле. Но зачастую 
реакция требуется только, если клавиша была нажата один раз, или когда игрок 
удерживает клавишу в течение некоторого периода времени. Тогда необходимо 
различать случаи, когда клавиша продолжает удерживаться или она была нажата 
снова. Для этого есть функция:

func int MEM_KeyState(var int key)

Она позволяет определить была ли клавиша на самом деле нажата или нет, 
учитывая, что в последний раз было возвращено для данной клавиши. Возможны 
следующие варианты возвращаемых значений:

KEY_UP: Клавиша не нажата и не была нажата до этого ("не нажата").
KEY_PRESSED: Клавиша сейчас нажата, но не была нажата до этого ("вновь 
нажата").
KEY_HOLD: Клавиша нажата сейчас и была нажата до этого ("все еще нажата").
KEY_RELEASED: Клавиша сейчас не нажата, но была нажата раньше ("отпущена").

KEY_PRESSED или KEY_RELEASED, таким образом, могут быть получены, только если 
состояние клавиши изменилось по сравнению с предыдущим вызовом.
KEY_UP или KEY_HOLD возвращаются, если условия не изменились.

Примечание: Если состояние клавиши меняется дважды между двумя проверками 
(например, клавишу быстро нажали и отпустили), MEM_KeyState этого не заметит. 
Эта функция проверяет состояние клавиш только в момент своего вызова.

Еще Примечание: Функция никогда не возвращает KEY_PRESSED два раза подряд. 
Вызов MEM_KeyState изменит ее результат в том же учатке кода. Например 
следующее абсолютно НЕВЕРНО НЕВЕРНО НЕВЕРНО:

//------ НЕ ТАК! -----
if (MEM_KeyState (KEY_RETURN) == KEY_UP) {  
  Print ("Клавиша не нажата!");
} else if (MEM_KeyState (KEY_RETURN) == KEY_PRESSED) {  
  Print ("Клавиша только что нажата!");
};
//----------------------

Блок else в этом коде никогда не будет выполнен. Если клавиша была нажата, 
значение KEY_PRESSED будет возвращено только в первом обращении. При втором 
обращении может быть получено только KEY_HOLD.

Такой вариант гораздо лучше:

//----------------------

var int returnState;
returnState = MEM_KeyState (KEY_RETURN);

if (returnState == KEY_UP) {  
	Print ("Клавиша не нажата!");
} else if (returnState == KEY_PRESSED) {  
	Print ("Клавиша только что нажата!");
};

//----------------------

При назначении множества событий по нажатию одной и той же клавиши, они также 
будут конкурировать за значение KEY_PRESSED!

//######################

Функция для имитации нажатия клавиши:

func void MEM_InsertKeyEvent(var int key)

В большинстве случаев, движок (в следующем фрейме) среагирует на нажатие 
клавиши, связанной с данным виртуальным кодом. Например, MEM_InsertKeyEvent
(KEY_ESC) откроет главное меню или закроет открытые документы, а 
MEM_InsertKeyEvent(KEY_TAB) откроет инвентарь, если в настройках TAB указан 
как клавиша, открывающая инвентарь.
В других случаях это не сработает, например, невозможно закрыть инвентарь 
таким способом.

Звучит немного неоднозначно, но такова реальность. Проблема состоит в том, 
что движок может отслеживать нажатия клавиш разными способами, и только один 
из этих способов имитируется MEM_InsertKeyEvent. Например будет работать:

 - открытие инвентаря (TAB)
 - открытие меню персонажа (C)
 - вкл./откл. паузы (F9)
 - открыть дневник (L)
 - открыть главное меню / закрыть документ (ESC)

Примечание: Разные игроки могут назначать разные клавиши в настройках! Но с 
помощью MEM_GetGothOpt можно узнать текущие настройки игры (Gothic.ini). Для 
каждого действия там указывается одна или две кнопки в 16-ричном формате 
(Внимание: прямой порядок байт (little-endian)!).

//######################################
// 9.) Выполнение машинного кода

Под машинным кодом понимается программа или фрагмент программного 
обеспечения, написанные на машинном языке, т.е. без необходимости трансляции 
для выполнения непосредственно процессором. В нашем случае подразумевается 
машинный язык для архитектуры процессора x86. Весь набор машинных команд, что 
они делают и как записываются, можно прочитать в руководстве Intel.

http://www.intel.com/products/processor/manuals/index.htm

На практике нам потребуется лишь несколько команд и лишь в редких случаях 
(абстрактных) возникнет желание вручную писать машинные инструкции в машинном 
коде (конкретном), поскольку это весьма непросто.

Машинный код может быть полезен для выполнения различных технических 
действий, которые не могут быть написаны на Daedalus. Например, используйте 
функции CALL (см. ниже) как основу набора функций ASM.

Примечание: Функции с префиксом "ASM_" для языка Ассемблер (Assembler). 
Ассемблер - это понятный человеку язык со взаимно однозначным соответсвием с 
машинными кодами. Строго говоря, префикс "ASM_" в данном случае некорректен, 
поскольку он относится к машинному коду, а не самому Ассемблеру. Они тесно 
связаны, но это не одно и то же.

Примечание: Я рекомендую всем, кто не собирается использовать возмножности 
этого раздела, пропустить его. Функции в этом разделе весьма специфичны и 
техничны. Тот, кто хочет использовать функции движка может просто вызывать 
функции "CALL_".
Функции "ASM_" весьма громоздки и будут полезны только с использованием 
ссылки Intel или с другого источника информации о машинных кодах.

//Базовые операции

Функция

func void ASM (var int data, var int length)

позволяет записывать машинные команды. Первые length байт данных data 
(максимум 4!) добавляются к ранее написанному машинному коду. Результат - 
последовательно исполняемая программа для процессора.

Присутсвует компактная запись в виде функций:

func void ASM_1 (var int data) { ASM (data, 1); };
func void ASM_2 (var int data) { ASM (data, 2); };
func void ASM_3 (var int data) { ASM (data, 3); };
func void ASM_4 (var int data) { ASM (data, 4); };

Отдельные машинные команды могут иметь длину более 4 байт, в этом случае их 
следует вводить по частям. В общем случае, используется логическое разделение 
на блоки по 4 байта (совпадающие по размеру с int).

Для выполнения набранного машинного кода используется функция

func void ASM_RunOnce()

Она выполняет набранный в данный момент машинный код, подобно вызову внешних 
функций. Записанный код выполняется, и затем можно писать новый код.

Примечание: Набранный код выполняется в сегменте данных. Если в Windows для 
Готики включено предотвращение выполнения данных DEP (что бывает крайне редко)
, могут возникнуть исключения защиты Windows, и Готика будет закрыта.

Примечание: Как вы могли заметить, в текущий момент можно набирать лишь один 
фрагмент машинного кода. Невозможно одновременно набирать две различных 
последовательности машинного кода.

Примечание: Система не надежна в отношении загрузки и сохранения операций. Не 
только бессмысленно, но и недопустимо, сохранять части кода в течении 
нескольких кадров. Набор кода завершается после вызова ASM_RunOnce или 
ASM_Close.

//Текущая позиция в программном коде 

При использовании, например, команд перехода и вызовов функций, может 
возникнуть необходимость узнать адрес исполняемого в данный момент 
программного кода. Функция

func int ASM_Here()

возвращает адрес курсора, иными словами, адрес памяти, по которому будет 
размещен результат следующего вызова ASM. Она гарантирует, что позиция кода 
соответствует точке, в котором он выполняется.

//Освобождение памяти

Память, в которой располагается машинный код, резервируется в начале набора. 
Если конкретный размер не указан, тогда, если набор явно начинается с помощью 
ASM или ASM_Here, то выделяется 256 байт памяти. Для простых приложений 
этого часто бывает достаточно.
Если требуется дополнительная память, то это должно быть явно объявлено в 
начале набора. Для этого существует специальная команда

func void ASM_Open(var int space)

Здесь space означает объем выделяемой памяти.

//Производительность

Если предполагается многократное использование функции за короткий промежуток 
времени, удобнее не набирать ее каждый раз заново. Для набора кода можно 
вместо ASM_RunOnce использовать 

func int ASM_Close()

для завершения. Эта функция завершает набор (так что начинается новый), и 
возвращает указатель на область памяти, которая содержит ранее набранный код. 
Этот указатель затем можно использовать в любое время и сколько угодно раз, 
с помощью 

func void ASM_Run(var int ptr)

передавая его в набор.

Но будьте осторожны: Область памяти, выделенная с помощью ASM_Close, должна 
быть вручную освобождена через MEM_Free, чтобы избежать утечки памяти. 
Вероятно, для большинства практических целей лучше использовать ASM_RunOnce и 
набирать код снова и снова, когда это необходимо.

Примечание: ASM_Run также можно использовать для вызова функций движка без 
параметров и возвращаемого значения. В этом случае ptr должен просто 
указывать на функцию, которую нужно выполнить в сегменте кода.

//Пример:

Следующая функция устанавливает переданного NPC slf в качестве игрока, как 
если бы вы нажали "O" с этим NPC в фокусе в режиме Marvin. Он такой короткий, 
поскольку, на самом деле, для этого уже существует функция, просто обычно 
она недоступна из скриптов. Поэтому в коде Ассемблера достаточно поместить 
указатель this в соответствующий реестр, а затем вызвать функцию.

func void SetAsPlayer (var C_NPC slf) {  
	/* Адрес функции  */  
	const int oCNpc__SetAsPlayer = 7612064; //0x7426A0 (Gothic2.exe)  
    
	var int slfPtr;  
	slfPtr = MEM_InstToPtr (slf);  
    
	//mov ecx slfPtr  
	ASM_1 (ASMINT_OP_movImToECX); /* поместить следующее значение в ecx */  
	ASM_4 (slfPtr); /* константа (размещаемое значение) */  
    
	//call oCNpc__SetAsPlayer  
	ASM_1 (ASMINT_OP_call);  
	ASM_4 (oCNpc__SetAsPlayer - ASM_Here() - 4);  
    
	ASM_RunOnce(); /* retn добавляется автоматически */
};

Примечание: Цель вызова задается относительно инструкции, которая выполняется 
непосредственно после команды call. Поэтому в параметрах вызова необходимы и 
ASM_Here(), и вычитание 4.

Примечание: Коды операций (opcodes) ASMINT_OP_movImToECX и ASMINT_OP_call 
объявлены в Ikarus.d как константы. Тем не менее, доступны лишь opcodes, 
необходимые непосредственно для скриптинга вызовов. Узнавать opcodes довольно 
утомительно.

Примечание: Следующий пункт описывает среди прочего CALL__thiscall, функцию, 
с использованием которой SetAsPlayer можно записать в виде:

func void SetAsPlayer (var C_NPC slf) {  
	const int oCNpc__SetAsPlayer = 7612064;  
	CALL__thiscall (MEM_InstToPtr (slf), oCNpc__SetAsPlayer);
};


//######################################
// 10. Вызов функций движка

Для использования функций необходимо знать их интерфейс, т.е. количество и 
тип параметров (что нужно знать функции?) и тип возвращаемого значения (что 
сообщит мне функция?). Это все. Что добавляется к случаю с уровнем машинного 
кода, так это соглашения о вызовах (как передается функция и ее параметры, 
кто освобождает память?) и адрес функции (где она вообще в памяти?).

Эти сведения о функциях движка можно получить, например, с помощью IDA, 
инструмента для анализа GothicMod.exe / Gothic2.exe и преобразования в 
доступную человеку (но все еще очень трудную) форму представления. Как 
получить хороший обзор GothicMod.exe / Gothic2.exe, Nico описал здесь:

http://forum.worldofplayers.de/forum/showpost.php?p=12395375

/*NS: Список всех доступных функций Готики 2 можно скачать в 4 уроке от 
redleha:
http://magic-team.net.ru/showthread.php?t=767
*/

Вооружитесь этими знаниями, а нижеприведенные функции позаботятся обо всем 
остальном. Они работают следующим образом.

//Шаг 1: Параметры справа налево

В первую очередь, функция ожидает параметры в обратном порядке: начиная с 
самого правого, и заканчивая самым левым, они помещаются в стек. Для этого 
служат функции:

func void CALL_IntParam        (var int    param) /* int32          */
func void CALL_FloatParam      (var int    param) /* single / zREAL */
func void CALL_PtrParam        (var int    param) /* void*          */
func void CALL_zStringPtrParam (var string param) /* zString*       */
func void CALL_cStringPtrParam (var string param) /* char **        */
func void CALL_StructParam (var int ptr, var int words) /* struct   */

Большинство параметров являются целыми числами или указателями. Поскольку в 
Daedalus нелегко перейти по указателю на строку, были реализованы специальные 
варианты "указатель на zString" и "указатель на cString". Это zString* или 
char**, каждый из которых содержит данные, передаваемые в виде строки в 
формате Daedalus. Полученное таким образом значение помещается в стек.

Изредка встречаются сложные параметры, представляющие собой объект или 
структуру, непосредственно помещаемую в стек (не как указатель). В этом 
случае в CALL_StructParam передается указатель на объект и его размер в 
словах (1 слово = 32 бита). CALL_StructParam целиком помещает объект в стек.

Примечание: CALL_IntParam, CALL_FloatParam и CALL_PtrParam  идентичны. 
Различие необходимо лишь для улучшения читаемости кода.

Изощрения: На самом деле эти функции не помещают параметры в машинный стек. 
Фактически следует читать: вы создаете машинный код, параметр помещается в 
машинный стек, потому что этот код выполняется. А выполняется он на втором 
шаге, с момента объявления соглашения о вызове.

//Шаг 2: Вызов

Имеется 4 варианта вызова:

func void CALL__stdcall  (var int adr                           )
func void CALL__thiscall (var int this, var int adr             )
func void CALL__cdecl    (var int adr                           )
func void CALL__fastcall (var int ecx,  var int edx, var int adr)

__stdcall служит для "Standard Call" (стандартного вызова) и является 
развитием соглашения __cdecl, как одного из наиболее важных. CALL__stdcall в 
качестве параметра требует только адрес вызываемой функции. В Windows API 
повсеместно используется соглашение о вызовах __stdcall.
__thiscall - этов вариант __stdcall для функций (методов) классов. 
В нем требуется указатель на this, т.е. указатель на объект, для которого 
вызывается функция, который помещается в регистр ECX. Поэтому в 
CALL__thiscall адрес функции дополняется указателем на объект. Поскольку в 
Gothic используется объектно-ориентированный подход, __thiscall является 
наиболее распространенным соглашением о вызовах.

Функции, которые не относятся к Windows API и не являются методами класса, 
часто используют соглашение о вызовах __cdecl. 
CALL__cdecl используется в точности как CALL__stdcall. Разница состоит во 
внутренней ответственности за управление указателем стека.

__fastcall не стандартизован. Некоторые компиляторы, включая компилятор 
Microsoft Visual Studio и Gothic, обеспечивают этот вариант вызова, как 
потенциально дающий чуть более высокую производительность. В случае Microsoft 
Visual Studio, первые два параметра помещаются через стек (в регистры ECX и 
EDX). __fastcall используется редко.

Определить, какое соглашение о вызовах использует конкретная функция движка, 
можно с помощью IDA (или другого дизассемблера).

Соглашения о вызовах объявлены, так что используйте одну из трех приведенных 
выше функций. К моменту вызова функции все параметры должны быть переданы.

//Шаг 3: Возвращаемое значение

После вызова функции, т.е. после шага 2, необходимо запросить возвращаемое 
значение. Следующие функции позволяют получить это значение (обычно как 
содержимое регистра EAX сразу после вызова) в формате, указанном в названии 
функции. Результат имеет тип данных, воспринимаемый языком Daedalus.

func int      CALL_RetValAsInt       () /* int */
func int      CALL_RetValAsPtr       () /* pointer   */
func instance CALL_RetValAsStructPtr () /* struct*  */
func string   CALL_RetValAszStringPtr() /* zString* */

CALL_RetValAsInt и CALL_RetValAsPtr возвращают значение просто как число.

CALL_RetValAsStructPtr можно использовать для присвоения инстанции, например 
переменной типа zCVob, если возвращается указатель на zCVob.

Если возвращается тип zString*, можно использовать CALL_RetValAszStringPtr, 
чтобы конвертировать результат к формату string в Daedalus.

Получение чисел с плавающей запятой - это особый случай (они не помещаются в 
регистр EAX). Перед объявлением типа вызова (и одновременно с самим 
выполнением вызова) необходимо прописать функцию:

func void CALL_RetValIsFloat()

чтобы сообщить об этом факте. Тогда получение результата после вызова не 
представляет проблемы.

func int      CALL_RetValAsFloat     () /* вещественное */

Примечание: CALL_RetValAsInt, CALL_RetValAsPtr и CALL_RetValAsFloat идентичны 
и просто выдают возвращаемое значение. Они введены только для улучшения 
читаемости кода.

//Сложные возвращаемые значения

В редких случаях возвращаемое значение представляет собой крупный объект (не 
указатель, а весь объект), например, zVEC3. Это особый случай. Необходимо 
вызывать

func void CALL_RetValIsStruct (var int words)

непосредственно перед объявлением о вызове (и одновременно с самим 
выполнением вызова). Размер структуры задается в словах (1 слово = 32 бита). 
Размер zVEC3, например, составляет 3 слова.
После этого резервируется необходимый объем внутренней памяти, и в стек в 
качестве скрытого параметра помещается указатель на эту область памяти. Затем 
вызванная функция заполняет это пространство и возвращает адрес результата 
(на самом деле в последнем нет необходимости, т.к. адрес уже известен). Таким 
образом, возвращаемое значение доступно из функций  CALL_RetValAsPtr или 
CALL_RetValAsStructPtr, как если бы возвращался не сам объект, а указатель на 
него.

Примечание: В случае сложного возвращаемого значения, возвращаемый объект 
создается специально для вызывающей функции. Поэтому из нее же необходимо 
освободить память, если объект более не нужен. Так, для zVEC3 необходимо 
освободить память, вызвав MEM_Free.

//Особый случай: возвращается zString

К особым случаям сложного возвращаемого объекта относится zString. Не так-то 
просто добиться безаварийного получения zString и правильного освобождения 
памяти (без "утечки"), так что были введены специальные функции:

func void   CALL_RetValIszString()
func string CALL_RetValAszString()

Здесь CALL_RetValIszString используется вместо CALL_RetValIsStruct.
CALL_RetValAszString создает копию возвращаемой строки в формате string для 
Daedalus и затем освобождает память для первоначально возвращенной строки.

Примечение: CALL_RetValAszStringPtr и CALL_RetValAszString отличаются, и их 
не следует путать. При вызове CALL_RetValAszString вместо 
CALL_RetValAszStringPtr происходит освобождение памяти, которая все еще 
используется. В обратном случае память не освобождается, хотя она уже не 
нужна (-> "утечка памяти").

//Пример:

MessageBox - это функция из WinAPI, в Gothic2 размещается по адресу 
0x7B48E8. Как она работает см. здесь:

http://msdn.microsoft.com/en-us/library/ms645505%28v=vs.85%29.aspx

Чтобы было удобно вызывать ее из Готики, напишем функцию для Deadalus, 
которая позаботится о передаче параметров и соглашении о вызове.

В IDA (или другом дизассемблере) найдем следующую запись:

int __stdcall MessageBoxA (HWND hWnd, LPCSTR lpText,  
                         LPCSTR lpCaption,UINT uType) 

где указано, что используется соглашение __stdcall. Кроме того, видно число  
и тип передаваемых параметров (все совпадает с документацией на MSDN). LPCSTR 
означает "Long Pointer to a c String", UINT - "unsigned Integer" и HWND - 
это указатель.

//----------------------

func int MEM_MessageBox (var string txt,  
                         var string caption, var int type) {  
	/* Адрес функции MessageBox */  
	const int WinAPI__MessageBox = 8079592; //0x7B48E8  
    
	/* Параметры в обратном порядке */  
	CALL_IntParam (type);           // int  
	CALL_cStringPtrParam (caption); // char **  
	CALL_cStringPtrParam (txt);     // char **  
	CALL_PtrParam (0);              // owner Window; должно быть равно нулю  
    
	/* вызов __stdcall */  
	CALL__stdcall (WinAPI__MessageBox);  
    
	return CALL_RetValAsInt();
};

//----------------------

Примечание: Это самый простой случай. Функции Готики не документированы. 
Значение параметров в общем случае неясно, и его можно только угадать или 
исследовать. И все же, адрес и синтаксис функции с приходом опыта можно без 
проблем получить из IDA (или другого дизассемблера).

//Другие примеры:

Следующие примеры предполагают, что MEM_InitAll или MEM_InitGlobalInst уже 
были вызваны, т.е. глобальные инстанции уже инициализированы.

1.) Получение указателя на игрока с помощью

.text:006C2C60:
class oCNpc * __thiscall oCGame::GetSelfPlayerVob(void)

//----------------------
{  
	const int oCGame__GetSelfPlayerVob = 7089248; //0x6C2C60  
    
	CALL__thiscall (MEM_InstToPtr (MEM_Game),  
	                oCGame__GetSelfPlayerVob);  
    
	var oCNpc player;  
	player = CALL_RetValAsStructPtr();  
    
	PrintDebug (player.name);
}
//----------------------

2.) Назначение оверлейной анимации с помощью

.text:0072D2C0:
int __thiscall oCNpc::ApplyOverlay(class zSTRING const &)

//----------------------
{  
	const int oCNpc__ApplyOverlay = 7525056; //0x72D2C0  
	CALL_zStringPtrParam ("HUMANS_MILITIA.MDS");  
	CALL__thiscall (MEM_InstToPtr (hero), oCNpc__ApplyOverlay);  
	//возвращаемое значение нас в данном случае не интересует
}
//----------------------

3.) Получение текущего игрового в виде строки, например, "7:30", с помощью

.text:00780EC0:
class zSTRING __thiscall oCWorldTimer::GetTimeString(void)

//----------------------
{  
	const int oCWorldTimer__GetTimeString = 7868096; //780EC0  
	CALL_RetValIszString();  
	CALL__thiscall (MEM_InstToPtr (MEM_WorldTimer),  
	                oCWorldTimer__GetTimeString     );  
	PrintDebug (CALL_RetValAszString());
}
//----------------------

Примечание: Тип возвращаемого значения в данном случае zString, т.е. объект 
длиной 20 байт. Об этом необходимо объявить с помощью CALL_RetValIszString, 
чтобы выделить необходимую память.
CALL_RetValAszString также позаботится о том, чтобы связанная память была 
освобождена. Для объектов, отличных от zString, это действие не 
автоматизировано.

4.) Получение "небесного времени", вещественного числа из диапазона от 0 до 1 
до полудня (12:00) или от 1 до 0 после полудня. Используем:

.text:00781240:
float __thiscall oCWorldTimer::GetSkyTime(void)

//----------------------
func int GetSkyTime() {  
	const int oCWorldTimer__GetSkyTime = 7868992; //0x781240  
	CALL_RetValIsFloat();  
	CALL__thiscall (MEM_InstToPtr (MEM_WorldTimer),  
				    oCWorldTimer__GetSkyTime);  
    
	return CALL_RetValAsFloat();
};
//----------------------

Примечание: поскольку возвращается число с плавающей запятой, необходимо 
вызвать CALL_RetValIsFloat.

//######################################
// 11.) Внешние библиотеки

Для загрузки DLL в Windows используется функция LoadLibrary, а для поиска 
функций в уже загруженной библиотеке - GetProcAddress.

Документацию по этим функциям можно найти здесь:

http://msdn.microsoft.com/en-us/library/ms684175%28v=vs.85%29.aspx
http://msdn.microsoft.com/en-us/library/ms683212%28v=vs.85%29.aspx

Ikarus предоставляет функции в точности так, как они описаны на MSDN:

func int LoadLibrary    (var string lpFileName)
func int GetProcAddress (var int hModule, var string lpProcName)

Адрес функции, полученный из GetProcAddress, можно использовать с помощью 
функций Call_, чтобы выполнить сам вызов. Например, можно вызвать функцию 
Sleep из Kernel32.dll:

//----------------------
func void Sleep(var int ms) {  
	var int adr;  
	adr = GetProcAddress (LoadLibrary ("KERNEL32.DLL"), "Sleep");  
    
	CALL_IntParam(ms);  
	CALL__stdcall(adr); //0x007B47E6
};
//----------------------

Документация для функции Sleep доступна на MSDN:

http://msdn.microsoft.com/en-us/library/ms686298%28v=vs.85%29.aspx

Поскольку Kernel32.dll - важная библиотека, Икарус предоставляет возможность 
быстрого доступа к ней с помощью:

func int FindKernelDllFunction (var string name)

FindKernelDllFunction эквивалентна GetProcAddress с адресом Kernel32.dll в 
качестве первого параметра.

//######################################
// 12.) Разное

func int MEM_SearchVobByName (var string str)

Возвращает адрес zCVobs с именем str, если таковой существует. В противном 
случае возвращается 0.

Как вариант существует

func int MEM_SearchAllVobsByName (var string str)

Эта функция создает zCArray, который содержит все VOB'ы с именем str. Если 
нет ни одного такого VOB'а, генерируется пустой массив zCArray. Функция 
возвращает ссылку на созданный zCArray. Его можно использовать, но необходимо 
освободить память до конца текущего кадра (прежде, чем его сможет загрузить 
игрок) с помощью MEM_ArrayFree, чтобы избежать утечки памяти.
Класс zCArray можно найти в файле Misc.d.

//******************

func int MEM_InsertVob(var string vis, var string wp)

Добавляет VOB с визуализацией (visual) vis в точку (waypoint) wp. Параметр 
vis должен содержать имя файла с расширением, например "FAKESCROLL.3DS", 
"FIRE.PFX", "SNA_BODY.ASC", "CHESTSMALL_NW_POOR_LOCKED.MDS" или 
"ADD_PIRATEFLAG.MMS".

Возвращает указатель на созданный объект. Если WP или визуализация не 
существуют, поведение данной функции не определено. 

Примечание: Объект создается как oCMob, поэтому можно узнать, например, его 
имя в фокусе (focusname). Но можно использовать его и как zCVob, если в 
дополнительных возможностях нет необходимости.

//******************

func void MEM_TriggerVob   (var int vobPtr)
func void MEM_UntriggerVob (var int vobPtr)

В обе этих функции в качестве параметра передается указатель на zCVob, и ему 
отправляется сообщение включения или отключения триггера. VOB временно 
переименовывается. Если с VOB'ом непосредственно связано какое-то действие, 
имя VOB'а подменяется на это время (до завершения MEM_TriggerVob). Не 
рекомендуется переименовывать или удалять объект в это время, поскольку 
поведение в такой ситуации не тестировалось.

//******************

func void MEM_RenameVob (var int vobPtr, var string newName)

Функция получает указатель на VOB и изменяет его имя на newName. Сначала 
объект удаляется из хэш-таблицы VOB'ов, затем переименовывается и вновь 
добавляется под новым именем.

//******************

func int Hlp_Is_oCMob(var int ptr)
func int Hlp_Is_oCMobInter(var int ptr)
func int Hlp_Is_oCMobLockable(var int ptr)
func int Hlp_Is_oCMobContainer(var int ptr)
func int Hlp_Is_oCMobDoor(var int ptr)
func int Hlp_Is_oCNpc(var int ptr)
func int Hlp_Is_oCItem(var int ptr)
func int Hlp_Is_zCMover(var int ptr)
func int Hlp_Is_oCMobFire(var int ptr)

Эти функции могут быть полезны при работе с фокусом ГГ. Функции возвращают 1, 
если переданный указатель ссылается на объект соответствующего класса или 
его дочерний класс.

Для табурета, например, Hlp_Is_oCMob и Hlp_Is_oCMobInter  вернут 1, а 
остальные функции - 0.

Разумеется, эти функции можно прописать и для других объектов, как MOB'ов, 
если есть такая необходимость.

//******************

func void MEM_SetShowDebug (var int on)

Устанавливает переменную, которая играет роль переключателя для вывода 
отладочных сообшений ("toggle debug"). Она связана с выводом сообщений в zSpy 
через PrintDebug (записываются как информационные). Рекомендуется 
использовать фильтр "Skript", чтобы полезная информация не оказалась 
погребена под грудой мусора.

//******************

func string MEM_GetCommandLine ()

Возвращает содержание командной строки, с которой была запущена Готика. 
Пример:

"-TIME:7:35 -GAME:TEST_IKARUS.INI -ZREPARSE -ZWINDOW -ZLOG:5,S -DEVMODE 
 - ZMAXFRAMERATE:30"

//******************

func int MEM_MessageBox (var string txt,  
                         var string caption,  
                         var int type)

Создает маленькое окно с  заголовком caption и сообщением txt. Возможные 
значения для type и возвращаемых значений можно найти по ссылке:

http://msdn.microsoft.com/en-us/library/ms645505%28v=vs.85%29.aspx

Все возможные константы приведены на этой странице.

Пример:

//----------------------
func void panic() {  
	if (MEM_MessageBox 
(          "Компьютер сейчас взорвется. Продолжить?",  
	       "Внимание!",  
	       MB_YESNO | MB_ICONWARNING)  
	                                  == IDYES) {  
		Print ("БУМ! Ты труп!");  
	} else {  
		Print ("Мудрое решение.");  
	};
};
//----------------------

В качестве частного случая MEM_MessageBox, введена функция MEM_InfoBox:

func void MEM_InfoBox (var string txt)

В окне сообщения выводится только кнопка OK и информационная иконка.

Окна сообщений приводят к выходу из полноэкранного режима, поэтому лучше их 
использовать только для отладки. 

//******************

func int MEM_GetSystemTime()

Возвращает время, прошедшее с запуска Готики, в миллисекундах.

//******************

func int MEM_BenchmarkMS(var func f)

MEM_BenchmarkMS выполняет переданную функцию f без параметров и возвращает 
время ее выполнения в миллисекундах (поэтому MS). Время выполнения может быть 
полезно для проверки, как функция влияет на производительность.

Однако миллисекунды зачастую являются слишком грубой единицей измерения, 
другими словами, миллисекунда - это очень долгое время выполнения. Более 
подходящими являются так называемые счетчики производительности, но их 
отсчеты зависят от производительности системы.

Количество тактов (тиков) счетчика производительности, затрачиваемых на 
выполнение функции, можно получить с помощью следующей модификации функции 
Benchmark:

func int MEM_BenchmarkPC(var func f)

Счетчик производительности удобно использовать для сравнения 
производительности двух функций. Возможно и преобразование в миллисекунды, 
количество тактов на одну миллисекунду записывается по адресу 
PC_TicksPerMS_Address. На моей системе на 1мс приходится 2741 такт. 
Преобразование в наносекунды может вызвать переполнение 32-битных целых, так 
что соблюдайте осторожность!

Для получения достоверных результатов рекомендуется замерять не однократное 
выполнение функции, а общее время ее цикличного вызова (например, 1000 раз). 
Результаты измерений искажаются особенно сильно, когда функции выполняются 
очень быстро. Поэтому существуют модификации функции Benchmark, которые 
содержат параметр, указывающий число прогонов функции f. Возвращается 
суммарная, а не средняя, характеристика длительности выполнения:

func int MEM_BenchmarkMS_N(var func f, var int n)
func int MEM_BenchmarkPC_N(var func f, var int n)

Комментарии по условиям измерений:
 - Параметр n следует выбирать так, чтобы результат ожидался из подходящего 
диапазона. Если n прогонов функции не займет и миллисекунды, разумеется, 
возвращаемое значений в миллисекундах будет незначительным.
 - Для *очень* быстрой функции f время, затрачиваемое на вызов функции 
Benchmark (а не на f) сильно влияет на измерения (так что результаты 
искажаются). Только относительно медленные функции можно измерить с 
достаточной достоверностью.

В качестве ориентира, здесь приведены результаты измерений для некоторых 
операций (в наносекундах = 1 миллиардная секунды):

 -  Вызов функции (переход к ней и обратно)		:     30ns
 -  Элементарная алгебра (напр.: i = i + 1)		:    130ns
 -  Wld_IsTime                                	:    200ns
 -  MEM_ReadInt, MEM_WriteInt                 	:    350ns
 -  Hlp_StrCmp("Hello", "Hello")              	:    500ns
 -  MEM_InstToPtr                             	:   1400ns
 -  Выделение и освобождение памяти (маленькой)	:   9700ns
 -  CALL__stdcall (дял пустой функции)			:  29000ns
 -  MEM_GetParserSymb								: 280000ns

 -  Итерация функции Benchmark					:    300ns

//******************

Доступ к статическим массивам в языке Daedalus довольно утомителен. Под 
статическим я подразумеваю обычный массив из скриптов, например:

var int myStaticArray[42];

Отсутствует возможность доступа к i-тому элементу myStaticArray[i] через 
переменную i, только через константы. Но все меняется со следующими функциями:

func int  MEM_ReadStatArr  (var int array, var int offset)
func void MEM_WriteStatArr (var int array, var int offset, var int value)

Команда:

MEM_WriteStatArr (myStaticArray, i, 23);

к примеру, запишет в i-тый элемент массива значение 23. Не важно, является ли 
i константой или переменной. Однако перед первым вызовом этих двух функций 
необходимо вызвать функцию:

func void MEM_InitStatArrs()

После каждой загрузки сохраненной игры следует вновь вызывать 
MEM_InitStatArrs().

Примечание: MEM_InitStatArrs также вызывается из MEM_InitAll.

Внимание: Обе функции выполняют своего рода проверку достоверности. Если 
передаваемое значение выходит за пределы массива, поведение не определено.

//******************

Иногда бывает нужно знать адрес переменной в памяти. В языке Daedalus такой 
возможности нет. Следующие функции восполняют пробел:

func int MEM_GetStringAddress(var string s)
func int MEM_GetFloatAddress (var float  f)
func int MEM_GetIntAddress   (var int    i)

Возвращаемое значение в каждом случае - это адрес переданной переменной. Если 
вместо переменной передать арифметическое выражение, (напр., 
MEM_GetIntAddress(x + 1)), никакой осмысленный результат не гарантируется.

Пример:

//----------------------
func void foo() {  
	MEM_GetAddress_Init();  
    
	//Пример для MEM_GetIntAddress  
	var int i;    i   = 0;  
	var int ptr;  ptr = MEM_GetIntAddress(i);  
        
	MEM_WriteInt(ptr, 42);  
	Print(IntToString(i)); //gibt "42" aus.  
        
	//Пример для MEM_GetStringAddress  
	var string str;   str  = "Hello";  
	var zString zStr; zStr = MEM_PtrToInst(MEM_GetStringAddress(str));  
    
	MEM_WriteByte(zStr.ptr, 66); //66 = B в таблице ASCII  
	Print(str); //<-выводится Bello.   
    
	//Два частных случая:  
	/* (1) */  
	ptr = MEM_GetStringAddress("Hello?");  
      
	/* (2) */  
	ptr = MEM_GetStringAddress(ConcatStrings("Hello", " World!"));
};
//----------------------

По поводу частных случаев в примере:
В случае (1) в ptr будет доступен адрес строки "Hello", размещенной где-то в 
таблице строк парсера.

Во втором случае (2) в ptr будет помещен адрес статической zStrings, 
используемой функцией ConcatStrings (и в данный момент содержащей "Hello 
World!").

ВАЖНО: Эти функции требуют предварительного вызова MEM_InitAll или 
MEM_GetAddress_Init.

//******************
func int  MEM_ArrayCreate ()
func void MEM_ArrayFree   (var int zCArray_ptr)
func void MEM_ArrayClear  (var int zCArray_ptr)
func void MEM_ArrayInsert (var int zCArray_ptr, var int value)

func void MEM_ArrayRemoveIndex     (var int zCArray_ptr, var int index)
func void MEM_ArrayRemoveValue     (var int zCArray_ptr, var int value)
func void MEM_ArrayRemoveValueOnce (var int zCArray_ptr, var int value)

zCArray - это очень простая структура данных, которая широко используется 
движком.

Массивы такого типа используются в скриптах для передачи большого объема 
данных. Например, MEM_SearchAllVobsByName использует массив, чтобы вернуть 
большое число VOB'ов. Необходимо освободить память в том же кадре с помощью 
MEM_ArrayFree (до того, как игрок сможет сохраниться или загрузиться).   

Выполнить вставку элементов в массив не так просто, поскольку в нем может 
быть недостаточно места, так что массив придется увеличить. Поэтому я 
запросил такую возможность. Следующий функции являются, так сказать, 
аксессуарами, делающими жизнь легче.
zCArray_ptr во всех функциях - это указатель на zCArray (см. Misc.d).

MEM_ArrayCreate: Создает пустой zCArray и возвращает его адрес.
MEM_ArrayFree:   Освобождает память zCArray и удаляет содержащиеся в нем 
данные.
MEM_ArrayClear:  Очищает данные в zCArray. Он становится пустым.
MEM_ArrayInsert: Добавляет значение в конец массива. Массив автоматически 
увеличивается, если он слишком мал.

Удаление элементов выполняется через заполнение дырки последним элементом. 
Если, к примеру, из массива (1,2,3,4,5) удалить 3, результатом будет: 
(1,2,5,4). Число 5 заполнило дырку.

MEM_ArrayRemoveIndex: Удаляет элемент в позиции Index.
MEM_ArrayRemoveValue: Ищет все вхождения элемента в массив, и удаляет их.
MEM_ArrayRemoveValueOnce: Ищет первое вхождение элемента в массив, и удаляет 
их. Если элемент не найден, выдается предупреждение.

Примечание: В эти функции следует передавать указатель на zCArray! Не 
спутайте с адресом первого элемента массива или индексом идентификатора "var 
zCArray" из таблицы символов! Иногда адрес zCArray можно получить только из 
адреса объекта, который содержит этот zCArray, и смещения zCArrays в этом 
классе (в байтах!).

Чтение и запись индексов организуется, например, через MEM_ReadIntArray, 
MEM_WriteIntArray применительно к zCArray.array. 

//******************

func void MEM_CopyBytes (var int src, var int dst, var int byteCount)
func void MEM_CopyWords (var int src, var int dst, var int wordcount)

func void MEM_SwapBytes (var int ptr1, var int ptr2, var int byteCount)
func void MEM_SwapWords (var int ptr1, var int ptr2, var int wordcount)

func int MEM_CompareBytes (var int ptr1, var int ptr2, var int byteCount)
func int MEM_CompareWords (var int ptr1, var int ptr2, var int wordcount)

Перечисленные выше функции работают с двумя областями памяти равного размера, 
первые два параметра указывают на начало этих областей. Третий параметр 
задает размер каждой из областей. Присутствует версия, в которой размер 
задается в байтах, и версия с размером в словах (1 слово = 4 байта, что 
совпадает с размером многих простых типов данных).

/* Copy */
Варианты MEM_Copy копируют заданное число байт или слов из источника src в 
dst (начиная с соответствующего адреса в памяти).

Примечание: Если адреса памяти перекрываются, поведение не определено. 

/* Swap */
"Swap" обозначает обмен. Данные, начиная с адреса ptr1, будут перемещены к 
адресу ptr2, и наоборот.

Примечание: Если адреса памяти перекрываются, поведение не определено. 
Примечание: Эта операция требует дополнительного объема памяти. 

/* Compare */
Варианты MEM_Compare выполняют сравнение данных в областях памяти, начиная с 
ptr1 и ptr2. Если они совпадают, возвращается 1, иначе 0.

//******************

func void MEM_InitAll()

Можно использовать вместо инициализации каждой отдельной возможности. Не 
делает ничего, кроме вызова MEM_InitGlobalInst, MEM_InitLabels, 
MEM_InitStatArrs, STR_GetAddressInit и MEM_ReinitParser.

Заметка: Рекомендуется вызов из INIT_GLOBAL. Тогда не потребуется больше 
никаких инициализаций после перезагрузки.

Внимание: Некоторые функции вызываются до INIT_GLOBAL. Например, генерация 
NPC. Если так необходима инициализация этих функций, например, во время 
генерации NPC, вызова MEM_InitAll в INIT_GLOBAL будет недостаточно. В этом 
случае рекомендуется еще раз вызвать нужную функцию там, где она 
используется. Повторные вызовы безопасны, и не оказывают заметного влияния на 
производительность.


//######################################
// 13.) "Скрытые" функции

Икарус предоставляет еще некоторые технические возможности, но их 
использование не обязательно сразу дает заметный эффект. Для большинства 
пользователей пакета отсутствует потребность в их использовании, но я все же 
объясню его здесь. 

//******************

func int MEM_GetFuncPtr(var func fnc)

Возвращает адрес функции языка Daedalus. Это участок памяти, с которого 
начинается код этой функции, т.е. адрес первого токена (token) функции 
(например, zPAR_TOK_PUSHVAR).

func int MEM_GetFuncOffset(var func fnc)

Похожа на MEM_GetFuncPtr, но возвращается не абсолютный адрес, а смещение 
относительно начала определенного кода. Команды перехода и вызовы функций 
являются примерами таких адресов.

//******************

func int MEM_GetClassDef (var int objPtr)

Получает указатель objPtr объекта zCObject O, к примеру, на zCVob или 
zCMaterial. Многие объекты, представляющие собой более чем простые структуры 
данных, являются прямыми или косвенными наследниками zCObject.
MEM_GetClassDef возвращает указатель на объект C типа zCClassDef. C содержит 
информацию о классе, к которому принадлежит O. Например, MEM_GetClassDef 
(MEM_InstToPtr (hero)) вернет указатель на объект zCClassDef, к которому 
относится класс oCNpc.

zCClassDef содержит некоторые интересные свойства (см. Misc.d).

func string MEM_GetClassName (var int objPtr)

представляет собой простое одно из возможных применений MEM_GetClassDef и 
возвращает имя класса, к которому принадлежит объект objPtr. К примеру, 
MEM_GetClassName (MEM_InstToPtr (hero)) вернет строку "oCNpc".

Если в эти функции передается указатель, не ссылающийся на zCObject, это 
может привести к вылету.

//******************

func int MEM_GetBufferCRC32 (var int buf, var int buflen) 

Вычисляет результат хэш-функции для массива байт, который начинается в buf и 
имеет длину buflen. Это та же хэш-функция, что используется в Готике.

func int MEM_GetStringHash (var string str) {

Вычисляет хэш строки. Это та же хэш-функция, что используется в Готике.

Примечание: Эта функция используется в MEM_SearchVobByName.

//******************

func int MEM_Alloc (var int amount)

MEM_Alloc выделяет amount байт памяти и возвращает указатель на выделенную 
область. Готика не получает ссылок на эту область памяти и не может 
освободить ее (даже в случае завершения сессии!). Память следует 
резервировать только, если вы можете гарантировать, что она будет освобождена 
с помощью MEM_Free прежде, чем произойдет загрузка сохраненной игры, или 
гарантировать, что Готика освободит эту память самостоятельно. Эту функцию 
можно использовать для генерации новых объектов и долгосрочного внедрения в 
объектную структуру Готики. Применяйте с большой осторожностью, поскольку 
отсутствует возможность использовать объектную  структуру Готики. Вам все 
придется делать вручную.

Очень удобно использовать эти функции для формирования небольших объектов, 
таких как элементы списков, и их интеграции в существующие списки. 
Незарезервированная память всегда обнуляется.

func int MEM_Realloc (var int oldptr, var int oldsize, var int newsize)

Выделяет область памяти размером newsize и возвращает указатель на эту 
область. Область памяти по ссылке oldptr освобождается. Если  newsize >= 
oldsize, oldsize первых байт передается из старой области памяти в новую. 
Если newsize <= oldsize все байты в выделенной области памяти 
инициализируются значениями из старой области. Эти функции используются для 
расширения или сжатия выделенной области памяти. Существующие данные 
сохраняются естественным образом.

func void MEM_Free (var int ptr)

Освобождает зарезервированную область памяти. Можно также уничтожить объекты, 
принадлежащие движку. И вновь, призываю к особой внимательности, поскольку 
деструкторы никогда не вызываются!

Маленькие объекты, вроде элементов списков, могут быть легко удалены.

//******************

func void MEM_SetParser(var int parserID)

Позволяет заменить текущий парсер на переданный в качестве параметра. Это 
может потребоваться, к примеру, для поиска и редактирования пунктов меню. 
Становится возможным взаимодействие со скриптами меню. Но, к сожалению, и 
здесь есть подводные камни, и это, вероятно, не так интересно, поскольку 
скрипты меню редко вызываются Готикой. Многие пункты меню сохраняются в 
памяти и вне игровой сессии.

//******************

func void MemoryProtectionOverride (var int address, var int size)

Попытка перезаписать сегмент кода или данных, доступных только для чтения, 
приведет к вылету. MemoryProtectionOverride регулирует защиту от записи для 
диапазона байт, начиная с адреса address и размером size.

Примечание: MemoryProtectionOverride снимает защиту от записи для всей 
страницы памяти, если она содержит хотя бы один байт из указанного диапазона. 
MemoryProtectionOverride использует функцию Windows VirtualProtect.


//######################################
// VI. ОПАСНОСТИ
//######################################

Этот скрипт-пакет не зря называется Икарус: вы можете оставить позади 
ограничения Дедалуса, но можете и рухнуть вниз головой. Если вы обратитесь к 
неверному адресу, это приведет не просто к предупреждению в ZSpy, а к вылету 
на рабочий стол с Access Violation. Это не повод для паники, но требует 
готовности к разочарованиям (но как скриптер вы можете воспользоваться и этим)
.

Разумеется, вы можете исправить все эти жуткие ошибки, и если будете работать 
сконцентрировано и по плану, то в итоге придете к чему-то осмысленному.

Короче: Необходима особая внимательность! Баги, приводящие к вылетам, - это 
не то, что хочется видеть в финальной версии. Но если человек работает 
аккуратно и детально тестирует то, что написал, все не так плохо.

Лучший помощник на случай вылетов - несомненно, точный вывод отладочной 
информации, так что используйте возможность отправки сообщений в ZSpy 
(например, чтобы локализовать участок кода, вызвавший вылет). Следует 
напомнить про функцию MEM_SetShowDebug и текстовый фильтр в zSpy (Options -> 
Textfilter).

//######################################
// VII. ПРИМЕРЫ
//######################################

//--------------------------------------
// 1.) Функция, открывающая сундук в фокусе игрока:

func void OpenFocussedChestOrDoor() {  
    var oCNpc her;  
    her = Hlp_GetNpc (hero);  
    
    //Есть ли вообще VOB в фокусе?  
    if (!her.focus_vob) {  
        Print ("Фокус пуст!!");  
        return;  
    };  
    
    //Является ли он запираемым?  
    if (!Hlp_Is_oCMobLockable(her.focus_vob)) {  
        Print ("В фокусе нет сундука или двери!");  
        return;  
    };  
    
    var oCMobLockable Lockable;  
    Lockable = MEM_PtrToInst (her.focus_vob);  
    
    if (Lockable.bitfield & oCMobLockable_bitfield_locked) {  
        Lockable.bitfield = Lockable.bitfield & ~ 
                                         oCMobLockable_bitfield_locked;  
        
        Print (ConcatStrings 
(                "VOB успешно открыт: ",  
              Lockable._zCObject_objectName));  
  } else {  
        Print (ConcatStrings 
(                Lockable._zCObject_objectName,  
                " не заперт!"));  
  };
};

//--------------------------------------
// 2.) Определение положения камеры:

func void PrintCameraPos() {  
    /* Инициализация глобальных (уникальных) инстанций: */  
    /* Инициализация MEM_World, MEM_Game и т.д., включая MEM_Camera */  
    MEM_InitGlobalInst();  
    
    /* Камера не является VOB'ом (это нечто абстрактное), так что непонятно, 
    где и как получить информацию о ее положении. Я предпочитаю работать со 
    связанным VOB'ом камеры: */  
    var zCVob camVob;  
    camVob = MEM_PtrToInst (MEM_Camera.connectedVob);  
    
    /*Теперь нам потребуются некоторые сведения о матрице преобразования 
    координат: 
 
      Она состоит из трех векторов (x, y и z) направлений в локальной 
    системе координат VOB'а камеры, определенных в глобальных 
    координатах (где z принимается за направление взгляда). Я обозначил 
    эти векторы v1, v2 и v3. Кроме того, имеется 4 столбец, содержащий 
    координаты камеры.  
 
        v1_x    v2_x    v3_x    x  
        v1_y    v2_y    v3_y    y  
        v1_z    v3_z    v3_z    z  
        0       0       0       0  
      
	  Матрица записывается в память построчно. Поскольку нас интересует 
    последняя колонка, нам нужны элементы массива с индексами 3, 7 и 11.  
  */  
    
    Print (ConcatStrings ("x: ", 
                        IntToString(roundf(camVob.trafoObjToWorld[ 3]))));  
    Print (ConcatStrings ("y: ", 
                        IntToString(roundf(camVob.trafoObjToWorld[ 7]))));  
    Print (ConcatStrings ("z: ", 
                        IntToString(roundf(camVob.trafoObjToWorld[11]))));
};

//--------------------------------------
// 3.) Включение дождя

func void StartRain() {  
    /* Инициализация глобальных инстанций: */  
    MEM_InitGlobalInst(); /* Включая Skycontroller (контроллер неба) */  
    
    /* возмоно, вы придумаете что-то получше,  
     * но я делаю так: */  
    
    /* Старт дождя в начале суток (12:00) */  
    MEM_SkyController.rainFX_timeStartRain = 0; //вещественный 0;  
    /* установка в конце суток (12:00 следующего дня) */  
    MEM_SkyController.rainFX_timeStopRain = 1065353216; //вещественная 1;  
    
    /* Примечание: время старта и остановки дождя - это числа
     * с плавающей запятой.  
     * 0 означает начало дня, 1 - конец дня.  
     * "Skytag" ведет отсчет от 12:00 дня.  
     * Чтобы получить число в формате IEEE 745, используйте Google.  
     * Я реализовал его в Daedalus:  
     * http://forum.worldofplayers.de/forum/showthread.php?t=500080  
     * Эту реализацию можно использовать,  
     * чтобы получить вещественные числа из целых (int -> zREAL). */  
    
    /* Результат: Круглосуточный дождь! (если вы находитесь в снежном районе,  
     * то будет весь день идти снег) */
};

//--------------------------------------
// 4.) Вложенный цикл  
  
/* Установить все пары в списке (x,y) равными:  
    0 <= x < max_x,  
    0 <= j < max_y
*/  
  
func void printpairs(var int max_x, var int max_y) {  
    /* Инициализация переходов */  
    MEM_InitLabels();  
    /* Включаем вывод отладочных сообщений PrintDebug */  
    MEM_SetShowDebug (1); 
 
    var int x; var int y;  
    x = 0;   
    
    /* while (x < max_x) */ /* пока (x < max_x) */  
    var int x_loop; x_loop = MEM_StackPos.position;  
    if (x < max_x) {  
        y = 0;  
        /* while (y < max_y) */ /* пока (y < max_y) */  
        var int y_loop; y_loop = MEM_StackPos.position;  
        if (y < max_y) {  
            var string out; out = "(";  
            out = ConcatStrings (out, IntToString (x));  
            out = ConcatStrings (out, ", ");  
            out = ConcatStrings (out, IntToString (y));  
            out = ConcatStrings (out, ")");  
            PrintDebug (out);  
            
            y += 1;  
            
            /* continue y_loop */ /* продолжить y_loop */  
            MEM_StackPos.position = y_loop;  
        };  
        
        x += 1;  
        
        /* continue x_loop */ /* продолжить x_loop */  
        MEM_StackPos.position = x_loop;  
    };
};

/* Результат для чисел (4,2) будет следующий:  
    00:36 Info:  5 U:    Skript: (0, 0) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (0, 1) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (1, 0) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (1, 1) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (2, 0) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (2, 1) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (3, 0) .... <zError.cpp,#465>  
    00:36 Info:  5 U:    Skript: (3, 1) .... <zError.cpp,#465>
*/

//--------------------------------------
// 5.) Вызов функции по имени

/* Этот пример не показывает, почему MEM_CallByString так полезна 
* на практике, но показывает, как ее использовать */ 

var zCVob someObject;
func int MyFunction(var int param1, var string str1,  
                    var int param2, var string str2) {  
    Print (ConcatStrings (str1, str2)); //(*)  
    return 100 * param1 + param2;
};

func void foo() {  
    var int result;  
    
    /* Код между A и B в данном случае эквивалентен вызову:  
     *   result = MyFunction (42, "Hello ", 23, "World!");  
     *                                                    */  
    
  /* A */  
    MEM_PushIntParam (42);  
    MEM_PushStringParam ("Hello ");  
    MEM_PushIntParam (23);  
    MEM_PushStringParam ("World!");  
    
    MEM_CallByString ("MYFUNCTION");  
    
    result = MEM_PopIntResult();  
  /* B */  
    
    Print (IntToString (result)); //(**)
};

/* Результатом будет вывод на экран "Hello World" (отмечено (*)) 
 * и "4223" (отмечено (**)). */

/* Примечание: Поскольку индексы символов в таблице 
 * следуют друг за другом непрерывно, 
 * индекс для someObject можно узнать 
 * из самого someObject, и вместо вызова 
 * MEM_CallByString ("MYFUNCTION"); 
 * здесь можно использовать 
 * MEM_CallByID (someObject + 1); */
